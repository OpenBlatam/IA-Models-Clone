"""
Gamma App - Advanced Export Engine
Multi-format export with advanced features and customization
"""

import asyncio
import json
import logging
import os
from datetime import datetime
from typing import Dict, List, Optional, Any, Union, BinaryIO
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path
import io
import zipfile
import tempfile

# Document generation
from reportlab.lib.pagesizes import letter, A4, A3
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT, TA_JUSTIFY

# Presentation generation
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE

# Web page generation
from jinja2 import Template, Environment, FileSystemLoader
import markdown
from bs4 import BeautifulSoup

# Image processing
from PIL import Image as PILImage, ImageDraw, ImageFont
import requests

# Video generation (basic)
import cv2
import numpy as np

logger = logging.getLogger(__name__)

class ExportFormat(Enum):
    """Export formats"""
    PDF = "pdf"
    DOCX = "docx"
    PPTX = "pptx"
    HTML = "html"
    MARKDOWN = "markdown"
    JSON = "json"
    XML = "xml"
    CSV = "csv"
    PNG = "png"
    JPG = "jpg"
    SVG = "svg"
    MP4 = "mp4"
    ZIP = "zip"

class ExportQuality(Enum):
    """Export quality levels"""
    DRAFT = "draft"
    STANDARD = "standard"
    HIGH = "high"
    PREMIUM = "premium"

@dataclass
class ExportConfig:
    """Export configuration"""
    format: ExportFormat
    quality: ExportQuality = ExportQuality.STANDARD
    include_metadata: bool = True
    include_watermark: bool = False
    watermark_text: str = "Generated by Gamma App"
    page_size: str = "A4"
    orientation: str = "portrait"
    margins: Dict[str, float] = None
    font_family: str = "Arial"
    font_size: int = 12
    line_spacing: float = 1.2
    color_scheme: Dict[str, str] = None
    custom_styles: Dict[str, Any] = None

@dataclass
class ExportResult:
    """Export result"""
    success: bool
    file_path: Optional[str] = None
    file_size: Optional[int] = None
    format: Optional[ExportFormat] = None
    error_message: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

class AdvancedExportEngine:
    """
    Advanced export engine with multiple formats and customization
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """Initialize export engine"""
        self.config = config or {}
        self.templates_dir = Path(self.config.get('templates_dir', 'templates'))
        self.output_dir = Path(self.config.get('output_dir', 'exports'))
        self.temp_dir = Path(self.config.get('temp_dir', 'temp'))
        
        # Create directories
        self.output_dir.mkdir(exist_ok=True)
        self.temp_dir.mkdir(exist_ok=True)
        
        # Initialize Jinja2 environment
        self.jinja_env = Environment(loader=FileSystemLoader(self.templates_dir))
        
        # Default configurations
        self.default_configs = {
            ExportFormat.PDF: ExportConfig(
                format=ExportFormat.PDF,
                page_size="A4",
                orientation="portrait",
                margins={"top": 1, "bottom": 1, "left": 1, "right": 1},
                font_family="Arial",
                font_size=12
            ),
            ExportFormat.PPTX: ExportConfig(
                format=ExportFormat.PPTX,
                quality=ExportQuality.STANDARD,
                font_family="Arial",
                font_size=18
            ),
            ExportFormat.HTML: ExportConfig(
                format=ExportFormat.HTML,
                quality=ExportQuality.STANDARD,
                include_metadata=True
            )
        }
        
        logger.info("Advanced Export Engine initialized successfully")

    async def export_content(self, content: Dict[str, Any], 
                           export_config: ExportConfig) -> ExportResult:
        """Export content in specified format"""
        try:
            # Validate content
            if not self._validate_content(content):
                return ExportResult(
                    success=False,
                    error_message="Invalid content format"
                )
            
            # Generate filename
            filename = self._generate_filename(content, export_config)
            output_path = self.output_dir / filename
            
            # Export based on format
            if export_config.format == ExportFormat.PDF:
                return await self._export_to_pdf(content, export_config, output_path)
            elif export_config.format == ExportFormat.PPTX:
                return await self._export_to_pptx(content, export_config, output_path)
            elif export_config.format == ExportFormat.HTML:
                return await self._export_to_html(content, export_config, output_path)
            elif export_config.format == ExportFormat.MARKDOWN:
                return await self._export_to_markdown(content, export_config, output_path)
            elif export_config.format == ExportFormat.JSON:
                return await self._export_to_json(content, export_config, output_path)
            elif export_config.format == ExportFormat.PNG:
                return await self._export_to_image(content, export_config, output_path)
            elif export_config.format == ExportFormat.ZIP:
                return await self._export_to_zip(content, export_config, output_path)
            else:
                return ExportResult(
                    success=False,
                    error_message=f"Unsupported export format: {export_config.format}"
                )
                
        except Exception as e:
            logger.error(f"Error exporting content: {e}")
            return ExportResult(
                success=False,
                error_message=str(e)
            )

    def _validate_content(self, content: Dict[str, Any]) -> bool:
        """Validate content structure"""
        required_fields = ['title', 'content']
        return all(field in content for field in required_fields)

    def _generate_filename(self, content: Dict[str, Any], 
                          config: ExportConfig) -> str:
        """Generate filename for export"""
        title = content.get('title', 'untitled')
        # Clean title for filename
        title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()
        title = title.replace(' ', '_').lower()
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"{title}_{timestamp}.{config.format.value}"

    async def _export_to_pdf(self, content: Dict[str, Any], 
                           config: ExportConfig, output_path: Path) -> ExportResult:
        """Export content to PDF"""
        try:
            # Get page size
            page_size = self._get_page_size(config.page_size, config.orientation)
            
            # Create PDF document
            doc = SimpleDocTemplate(
                str(output_path),
                pagesize=page_size,
                rightMargin=config.margins['right'] * inch,
                leftMargin=config.margins['left'] * inch,
                topMargin=config.margins['top'] * inch,
                bottomMargin=config.margins['bottom'] * inch
            )
            
            # Get styles
            styles = getSampleStyleSheet()
            custom_styles = self._create_custom_styles(styles, config)
            
            # Build content
            story = []
            
            # Title
            title_style = custom_styles.get('Title', styles['Title'])
            story.append(Paragraph(content['title'], title_style))
            story.append(Spacer(1, 12))
            
            # Content sections
            for section in content.get('sections', []):
                # Section title
                if 'title' in section:
                    section_style = custom_styles.get('Heading1', styles['Heading1'])
                    story.append(Paragraph(section['title'], section_style))
                    story.append(Spacer(1, 6))
                
                # Section content
                if 'content' in section:
                    content_style = custom_styles.get('Normal', styles['Normal'])
                    story.append(Paragraph(section['content'], content_style))
                    story.append(Spacer(1, 12))
                
                # Tables
                if 'table' in section:
                    table = self._create_pdf_table(section['table'], custom_styles)
                    story.append(table)
                    story.append(Spacer(1, 12))
                
                # Images
                if 'images' in section:
                    for image_data in section['images']:
                        image = self._create_pdf_image(image_data)
                        if image:
                            story.append(image)
                            story.append(Spacer(1, 12))
            
            # Watermark
            if config.include_watermark:
                self._add_watermark(doc, config.watermark_text)
            
            # Build PDF
            doc.build(story)
            
            # Get file size
            file_size = output_path.stat().st_size
            
            return ExportResult(
                success=True,
                file_path=str(output_path),
                file_size=file_size,
                format=ExportFormat.PDF,
                metadata={
                    "page_count": len(story),
                    "created_at": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating PDF: {e}")
            return ExportResult(success=False, error_message=str(e))

    async def _export_to_pptx(self, content: Dict[str, Any], 
                            config: ExportConfig, output_path: Path) -> ExportResult:
        """Export content to PowerPoint"""
        try:
            # Create presentation
            prs = Presentation()
            
            # Set slide size
            if config.page_size == "A4":
                prs.slide_width = Inches(10)
                prs.slide_height = Inches(7.5)
            else:
                prs.slide_width = Inches(10)
                prs.slide_height = Inches(7.5)
            
            # Title slide
            title_slide_layout = prs.slide_layouts[0]
            slide = prs.slides.add_slide(title_slide_layout)
            title = slide.shapes.title
            subtitle = slide.placeholders[1]
            
            title.text = content['title']
            subtitle.text = content.get('subtitle', 'Generated by Gamma App')
            
            # Content slides
            for section in content.get('sections', []):
                # Create slide
                content_slide_layout = prs.slide_layouts[1]
                slide = prs.slides.add_slide(content_slide_layout)
                
                # Section title
                title_shape = slide.shapes.title
                title_shape.text = section.get('title', 'Section')
                
                # Section content
                content_shape = slide.placeholders[1]
                text_frame = content_shape.text_frame
                text_frame.clear()
                
                # Add content paragraphs
                content_text = section.get('content', '')
                paragraphs = content_text.split('\n\n')
                
                for i, paragraph_text in enumerate(paragraphs):
                    if i == 0:
                        p = text_frame.paragraphs[0]
                    else:
                        p = text_frame.add_paragraph()
                    
                    p.text = paragraph_text
                    p.font.size = Pt(config.font_size)
                    p.font.name = config.font_family
                
                # Add images if present
                if 'images' in section:
                    for image_data in section['images']:
                        self._add_image_to_slide(slide, image_data)
                
                # Add tables if present
                if 'table' in section:
                    self._add_table_to_slide(slide, section['table'])
            
            # Save presentation
            prs.save(str(output_path))
            
            # Get file size
            file_size = output_path.stat().st_size
            
            return ExportResult(
                success=True,
                file_path=str(output_path),
                file_size=file_size,
                format=ExportFormat.PPTX,
                metadata={
                    "slide_count": len(prs.slides),
                    "created_at": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating PowerPoint: {e}")
            return ExportResult(success=False, error_message=str(e))

    async def _export_to_html(self, content: Dict[str, Any], 
                            config: ExportConfig, output_path: Path) -> ExportResult:
        """Export content to HTML"""
        try:
            # Load template
            template = self.jinja_env.get_template('export.html')
            
            # Prepare template data
            template_data = {
                'title': content['title'],
                'content': content,
                'config': config,
                'generated_at': datetime.now().isoformat(),
                'include_metadata': config.include_metadata
            }
            
            # Render HTML
            html_content = template.render(**template_data)
            
            # Write to file
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            # Get file size
            file_size = output_path.stat().st_size
            
            return ExportResult(
                success=True,
                file_path=str(output_path),
                file_size=file_size,
                format=ExportFormat.HTML,
                metadata={
                    "created_at": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating HTML: {e}")
            return ExportResult(success=False, error_message=str(e))

    async def _export_to_markdown(self, content: Dict[str, Any], 
                                config: ExportConfig, output_path: Path) -> ExportResult:
        """Export content to Markdown"""
        try:
            markdown_content = f"# {content['title']}\n\n"
            
            # Add metadata if requested
            if config.include_metadata:
                markdown_content += f"*Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n"
            
            # Add content sections
            for section in content.get('sections', []):
                if 'title' in section:
                    markdown_content += f"## {section['title']}\n\n"
                
                if 'content' in section:
                    markdown_content += f"{section['content']}\n\n"
                
                # Add tables
                if 'table' in section:
                    markdown_content += self._table_to_markdown(section['table'])
                    markdown_content += "\n\n"
            
            # Write to file
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            
            # Get file size
            file_size = output_path.stat().st_size
            
            return ExportResult(
                success=True,
                file_path=str(output_path),
                file_size=file_size,
                format=ExportFormat.MARKDOWN,
                metadata={
                    "created_at": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating Markdown: {e}")
            return ExportResult(success=False, error_message=str(e))

    async def _export_to_json(self, content: Dict[str, Any], 
                            config: ExportConfig, output_path: Path) -> ExportResult:
        """Export content to JSON"""
        try:
            # Prepare JSON data
            json_data = {
                "title": content['title'],
                "content": content,
                "metadata": {
                    "exported_at": datetime.now().isoformat(),
                    "format": config.format.value,
                    "quality": config.quality.value
                }
            }
            
            # Write to file
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
            
            # Get file size
            file_size = output_path.stat().st_size
            
            return ExportResult(
                success=True,
                file_path=str(output_path),
                file_size=file_size,
                format=ExportFormat.JSON,
                metadata={
                    "created_at": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating JSON: {e}")
            return ExportResult(success=False, error_message=str(e))

    async def _export_to_image(self, content: Dict[str, Any], 
                             config: ExportConfig, output_path: Path) -> ExportResult:
        """Export content to image"""
        try:
            # Create image
            width, height = 1200, 800
            image = PILImage.new('RGB', (width, height), 'white')
            draw = ImageDraw.Draw(image)
            
            # Try to load font
            try:
                font = ImageFont.truetype("arial.ttf", 24)
                small_font = ImageFont.truetype("arial.ttf", 16)
            except:
                font = ImageFont.load_default()
                small_font = ImageFont.load_default()
            
            # Draw title
            title = content['title']
            draw.text((50, 50), title, fill='black', font=font)
            
            # Draw content
            y_position = 100
            for section in content.get('sections', []):
                if 'title' in section:
                    draw.text((50, y_position), section['title'], fill='blue', font=small_font)
                    y_position += 30
                
                if 'content' in section:
                    # Simple text wrapping
                    content_text = section['content']
                    words = content_text.split()
                    line = ""
                    for word in words:
                        test_line = line + word + " "
                        bbox = draw.textbbox((0, 0), test_line, font=small_font)
                        if bbox[2] - bbox[0] < width - 100:
                            line = test_line
                        else:
                            draw.text((50, y_position), line, fill='black', font=small_font)
                            y_position += 20
                            line = word + " "
                    
                    if line:
                        draw.text((50, y_position), line, fill='black', font=small_font)
                        y_position += 20
                
                y_position += 20
            
            # Save image
            image.save(output_path, 'PNG')
            
            # Get file size
            file_size = output_path.stat().st_size
            
            return ExportResult(
                success=True,
                file_path=str(output_path),
                file_size=file_size,
                format=ExportFormat.PNG,
                metadata={
                    "image_size": f"{width}x{height}",
                    "created_at": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating image: {e}")
            return ExportResult(success=False, error_message=str(e))

    async def _export_to_zip(self, content: Dict[str, Any], 
                           config: ExportConfig, output_path: Path) -> ExportResult:
        """Export content to ZIP with multiple formats"""
        try:
            with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                # Export to multiple formats
                formats_to_export = [
                    ExportFormat.PDF,
                    ExportFormat.HTML,
                    ExportFormat.MARKDOWN,
                    ExportFormat.JSON
                ]
                
                for fmt in formats_to_export:
                    try:
                        export_config = ExportConfig(
                            format=fmt,
                            quality=config.quality,
                            include_metadata=config.include_metadata
                        )
                        
                        # Create temporary file
                        temp_file = self.temp_dir / f"temp_{fmt.value}"
                        
                        # Export to temporary file
                        result = await self.export_content(content, export_config)
                        if result.success and result.file_path:
                            # Add to ZIP
                            zipf.write(result.file_path, f"content.{fmt.value}")
                            
                            # Clean up temporary file
                            Path(result.file_path).unlink(missing_ok=True)
                    
                    except Exception as e:
                        logger.warning(f"Failed to export {fmt.value}: {e}")
                        continue
                
                # Add metadata file
                metadata = {
                    "title": content['title'],
                    "exported_at": datetime.now().isoformat(),
                    "formats_included": [fmt.value for fmt in formats_to_export],
                    "quality": config.quality.value
                }
                
                zipf.writestr("metadata.json", json.dumps(metadata, indent=2))
            
            # Get file size
            file_size = output_path.stat().st_size
            
            return ExportResult(
                success=True,
                file_path=str(output_path),
                file_size=file_size,
                format=ExportFormat.ZIP,
                metadata={
                    "formats_included": [fmt.value for fmt in formats_to_export],
                    "created_at": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error creating ZIP: {e}")
            return ExportResult(success=False, error_message=str(e))

    def _get_page_size(self, page_size: str, orientation: str):
        """Get page size for PDF"""
        size_map = {
            "A4": A4,
            "A3": A3,
            "Letter": letter
        }
        
        size = size_map.get(page_size, A4)
        
        if orientation == "landscape":
            return (size[1], size[0])
        else:
            return size

    def _create_custom_styles(self, styles, config: ExportConfig):
        """Create custom styles for PDF"""
        custom_styles = {}
        
        # Title style
        custom_styles['Title'] = ParagraphStyle(
            'CustomTitle',
            parent=styles['Title'],
            fontName=config.font_family,
            fontSize=config.font_size + 8,
            spaceAfter=30,
            alignment=TA_CENTER
        )
        
        # Heading styles
        custom_styles['Heading1'] = ParagraphStyle(
            'CustomHeading1',
            parent=styles['Heading1'],
            fontName=config.font_family,
            fontSize=config.font_size + 4,
            spaceAfter=12
        )
        
        # Normal style
        custom_styles['Normal'] = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontName=config.font_family,
            fontSize=config.font_size,
            leading=config.font_size * config.line_spacing
        )
        
        return custom_styles

    def _create_pdf_table(self, table_data: List[List[str]], styles):
        """Create table for PDF"""
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 14),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        return table

    def _create_pdf_image(self, image_data: Dict[str, Any]):
        """Create image for PDF"""
        try:
            if 'url' in image_data:
                # Download image
                response = requests.get(image_data['url'])
                image_path = io.BytesIO(response.content)
                return Image(image_path, width=4*inch, height=3*inch)
            elif 'path' in image_data:
                return Image(image_data['path'], width=4*inch, height=3*inch)
        except Exception as e:
            logger.error(f"Error creating PDF image: {e}")
        return None

    def _add_watermark(self, doc, watermark_text: str):
        """Add watermark to PDF"""
        # This would be implemented with reportlab's watermark functionality
        pass

    def _add_image_to_slide(self, slide, image_data: Dict[str, Any]):
        """Add image to PowerPoint slide"""
        try:
            if 'url' in image_data:
                # Download and add image
                response = requests.get(image_data['url'])
                image_path = io.BytesIO(response.content)
                slide.shapes.add_picture(image_path, Inches(1), Inches(2), width=Inches(4))
        except Exception as e:
            logger.error(f"Error adding image to slide: {e}")

    def _add_table_to_slide(self, slide, table_data: List[List[str]]):
        """Add table to PowerPoint slide"""
        try:
            rows = len(table_data)
            cols = len(table_data[0]) if table_data else 0
            
            left = Inches(1)
            top = Inches(2)
            width = Inches(8)
            height = Inches(4)
            
            table = slide.shapes.add_table(rows, cols, left, top, width, height).table
            
            for i, row_data in enumerate(table_data):
                for j, cell_data in enumerate(row_data):
                    table.cell(i, j).text = str(cell_data)
        except Exception as e:
            logger.error(f"Error adding table to slide: {e}")

    def _table_to_markdown(self, table_data: List[List[str]]) -> str:
        """Convert table to Markdown format"""
        if not table_data:
            return ""
        
        markdown = ""
        
        # Header
        header = "| " + " | ".join(table_data[0]) + " |"
        markdown += header + "\n"
        
        # Separator
        separator = "| " + " | ".join(["---"] * len(table_data[0])) + " |"
        markdown += separator + "\n"
        
        # Rows
        for row in table_data[1:]:
            row_markdown = "| " + " | ".join(row) + " |"
            markdown += row_markdown + "\n"
        
        return markdown

    def get_supported_formats(self) -> List[ExportFormat]:
        """Get list of supported export formats"""
        return list(ExportFormat)

    def get_export_config(self, format: ExportFormat) -> ExportConfig:
        """Get default export configuration for format"""
        return self.default_configs.get(format, ExportConfig(format=format))

    async def batch_export(self, content_list: List[Dict[str, Any]], 
                          export_config: ExportConfig) -> List[ExportResult]:
        """Export multiple content items"""
        results = []
        
        for i, content in enumerate(content_list):
            try:
                # Modify config for batch export
                batch_config = ExportConfig(**asdict(export_config))
                batch_config.include_watermark = True
                batch_config.watermark_text = f"Batch Export {i+1} - Generated by Gamma App"
                
                result = await self.export_content(content, batch_config)
                results.append(result)
                
            except Exception as e:
                logger.error(f"Error in batch export item {i}: {e}")
                results.append(ExportResult(
                    success=False,
                    error_message=str(e)
                ))
        
        return results



























