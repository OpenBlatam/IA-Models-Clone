#!/usr/bin/env python3
"""
Vulnerability Scanner Module for Video-OpusClip
Scans for common vulnerabilities in web applications and services
"""

import asyncio
import aiohttp
import ssl
import socket
import hashlib
import json
import re
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass
from enum import Enum
from datetime import datetime, timedelta
from urllib.parse import urljoin, urlparse
import subprocess
import nmap

class VulnerabilityType(str, Enum):
    """Types of vulnerabilities"""
    SQL_INJECTION = "sql_injection"
    XSS = "cross_site_scripting"
    CSRF = "cross_site_request_forgery"
    OPEN_REDIRECT = "open_redirect"
    FILE_INCLUSION = "file_inclusion"
    COMMAND_INJECTION = "command_injection"
    WEAK_SSL = "weak_ssl"
    DEFAULT_CREDENTIALS = "default_credentials"
    OUTDATED_SOFTWARE = "outdated_software"
    EXPOSED_ENDPOINTS = "exposed_endpoints"

class SeverityLevel(str, Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class Vulnerability:
    """Vulnerability information"""
    type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    affected_url: Optional[str] = None
    affected_parameter: Optional[str] = None
    payload: Optional[str] = None
    evidence: Optional[str] = None
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    remediation: Optional[str] = None
    discovered_at: datetime = None
    
    def __post_init__(self):
        if self.discovered_at is None:
            self.discovered_at = datetime.utcnow()

@dataclass
class ScanConfig:
    """Configuration for vulnerability scanning"""
    target_url: str
    scan_depth: int = 3
    max_concurrent: int = 10
    timeout: float = 30.0
    user_agent: str = "Video-OpusClip-Scanner/1.0"
    follow_redirects: bool = True
    verify_ssl: bool = False
    scan_types: List[VulnerabilityType] = None
    custom_headers: Dict[str, str] = None
    
    def __post_init__(self):
        if self.scan_types is None:
            self.scan_types = [
                VulnerabilityType.SQL_INJECTION,
                VulnerabilityType.XSS,
                VulnerabilityType.OPEN_REDIRECT,
                VulnerabilityType.EXPOSED_ENDPOINTS
            ]
        if self.custom_headers is None:
            self.custom_headers = {}

class VulnerabilityScanner:
    """Vulnerability scanner for web applications"""
    
    def __init__(self, config: ScanConfig):
        self.config = config
        self.vulnerabilities: List[Vulnerability] = []
        self.scanned_urls: set = set()
        self.session: Optional[aiohttp.ClientSession] = None
        self.scan_start_time: float = 0.0
        self.scan_end_time: float = 0.0
    
    async def scan_target(self) -> Dict[str, Any]:
        """Perform comprehensive vulnerability scan"""
        self.scan_start_time = asyncio.get_event_loop().time()
        
        try:
            # Initialize session
            connector = aiohttp.TCPConnector(ssl=False if not self.config.verify_ssl else None)
            self.session = aiohttp.ClientSession(
                connector=connector,
                timeout=aiohttp.ClientTimeout(total=self.config.timeout),
                headers={
                    "User-Agent": self.config.user_agent,
                    **self.config.custom_headers
                }
            )
            
            # Start scanning
            await self._crawl_and_scan()
            
            # Perform additional scans
            if VulnerabilityType.WEAK_SSL in self.config.scan_types:
                await self._scan_ssl_vulnerabilities()
            
            if VulnerabilityType.DEFAULT_CREDENTIALS in self.config.scan_types:
                await self._scan_default_credentials()
            
            self.scan_end_time = asyncio.get_event_loop().time()
            
            return {
                "success": True,
                "target": self.config.target_url,
                "total_vulnerabilities": len(self.vulnerabilities),
                "scan_duration": self.scan_end_time - self.scan_start_time,
                "scanned_urls": len(self.scanned_urls),
                "vulnerabilities": [self._vulnerability_to_dict(v) for v in self.vulnerabilities]
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "target": self.config.target_url
            }
        finally:
            if self.session:
                await self.session.close()
    
    async def _crawl_and_scan(self) -> None:
        """Crawl and scan URLs"""
        urls_to_scan = [self.config.target_url]
        scanned_urls = set()
        
        for depth in range(self.config.scan_depth):
            current_urls = urls_to_scan.copy()
            urls_to_scan.clear()
            
            # Scan current level URLs
            semaphore = asyncio.Semaphore(self.config.max_concurrent)
            tasks = [
                self._scan_url_with_semaphore(url, semaphore)
                for url in current_urls
                if url not in scanned_urls
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, dict) and result.get("success"):
                    scanned_urls.add(result["url"])
                    # Add new URLs for next level
                    if depth < self.config.scan_depth - 1:
                        urls_to_scan.extend(result.get("new_urls", []))
    
    async def _scan_url_with_semaphore(self, url: str, semaphore: asyncio.Semaphore) -> Dict[str, Any]:
        """Scan URL with semaphore for concurrency control"""
        async with semaphore:
            return await self._scan_single_url(url)
    
    async def _scan_single_url(self, url: str) -> Dict[str, Any]:
        """Scan a single URL for vulnerabilities"""
        try:
            # Fetch the page
            async with self.session.get(url, allow_redirects=self.config.follow_redirects) as response:
                content = await response.text()
                self.scanned_urls.add(url)
                
                # Extract forms and parameters
                forms = self._extract_forms(content, url)
                parameters = self._extract_parameters(url)
                
                # Perform vulnerability tests
                vulnerabilities = []
                
                if VulnerabilityType.SQL_INJECTION in self.config.scan_types:
                    sql_vulns = await self._test_sql_injection(url, forms, parameters)
                    vulnerabilities.extend(sql_vulns)
                
                if VulnerabilityType.XSS in self.config.scan_types:
                    xss_vulns = await self._test_xss(url, forms, parameters)
                    vulnerabilities.extend(xss_vulns)
                
                if VulnerabilityType.OPEN_REDIRECT in self.config.scan_types:
                    redirect_vulns = await self._test_open_redirect(url, parameters)
                    vulnerabilities.extend(redirect_vulns)
                
                if VulnerabilityType.EXPOSED_ENDPOINTS in self.config.scan_types:
                    endpoint_vulns = await self._test_exposed_endpoints(url)
                    vulnerabilities.extend(endpoint_vulns)
                
                # Add vulnerabilities to global list
                self.vulnerabilities.extend(vulnerabilities)
                
                # Extract new URLs for crawling
                new_urls = self._extract_urls(content, url)
                
                return {
                    "success": True,
                    "url": url,
                    "vulnerabilities": len(vulnerabilities),
                    "new_urls": new_urls
                }
                
        except Exception as e:
            return {
                "success": False,
                "url": url,
                "error": str(e)
            }
    
    async def _test_sql_injection(self, url: str, forms: List[Dict], parameters: List[str]) -> List[Vulnerability]:
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        # SQL injection payloads
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' OR 1=1#",
            "admin'--",
            "1' AND '1'='1",
            "1' AND '1'='2"
        ]
        
        # Test URL parameters
        for param in parameters:
            for payload in payloads:
                test_url = self._inject_payload(url, param, payload)
                try:
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check for SQL error indicators
                        if self._detect_sql_error(content):
                            vuln = Vulnerability(
                                type=VulnerabilityType.SQL_INJECTION,
                                severity=SeverityLevel.HIGH,
                                title="SQL Injection Vulnerability",
                                description=f"SQL injection detected in parameter '{param}'",
                                affected_url=url,
                                affected_parameter=param,
                                payload=payload,
                                evidence=f"SQL error detected in response",
                                remediation="Use parameterized queries and input validation"
                            )
                            vulnerabilities.append(vuln)
                            break
                            
                except Exception:
                    continue
        
        # Test form inputs
        for form in forms:
            for field_name in form.get("fields", []):
                for payload in payloads:
                    try:
                        data = {field_name: payload}
                        async with self.session.post(form["action"], data=data) as response:
                            content = await response.text()
                            
                            if self._detect_sql_error(content):
                                vuln = Vulnerability(
                                    type=VulnerabilityType.SQL_INJECTION,
                                    severity=SeverityLevel.HIGH,
                                    title="SQL Injection in Form",
                                    description=f"SQL injection detected in form field '{field_name}'",
                                    affected_url=form["action"],
                                    affected_parameter=field_name,
                                    payload=payload,
                                    evidence=f"SQL error detected in response",
                                    remediation="Use parameterized queries and input validation"
                                )
                                vulnerabilities.append(vuln)
                                break
                                
                    except Exception:
                        continue
        
        return vulnerabilities
    
    async def _test_xss(self, url: str, forms: List[Dict], parameters: List[str]) -> List[Vulnerability]:
        """Test for XSS vulnerabilities"""
        vulnerabilities = []
        
        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'><script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>"
        ]
        
        # Test URL parameters
        for param in parameters:
            for payload in payloads:
                test_url = self._inject_payload(url, param, payload)
                try:
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check if payload is reflected in response
                        if payload in content:
                            vuln = Vulnerability(
                                type=VulnerabilityType.XSS,
                                severity=SeverityLevel.MEDIUM,
                                title="Cross-Site Scripting (XSS)",
                                description=f"XSS vulnerability detected in parameter '{param}'",
                                affected_url=url,
                                affected_parameter=param,
                                payload=payload,
                                evidence=f"Payload reflected in response",
                                remediation="Implement proper input validation and output encoding"
                            )
                            vulnerabilities.append(vuln)
                            break
                            
                except Exception:
                    continue
        
        return vulnerabilities
    
    async def _test_open_redirect(self, url: str, parameters: List[str]) -> List[Vulnerability]:
        """Test for open redirect vulnerabilities"""
        vulnerabilities = []
        
        # Redirect payloads
        payloads = [
            "https://evil.com",
            "//evil.com",
            "javascript:alert('redirect')",
            "data:text/html,<script>alert('redirect')</script>"
        ]
        
        redirect_params = ["redirect", "url", "next", "target", "return", "returnTo"]
        
        for param in parameters:
            if any(redirect_param in param.lower() for redirect_param in redirect_params):
                for payload in payloads:
                    test_url = self._inject_payload(url, param, payload)
                    try:
                        async with self.session.get(test_url, allow_redirects=False) as response:
                            if response.status in [301, 302, 303, 307, 308]:
                                location = response.headers.get("Location", "")
                                if payload in location:
                                    vuln = Vulnerability(
                                        type=VulnerabilityType.OPEN_REDIRECT,
                                        severity=SeverityLevel.MEDIUM,
                                        title="Open Redirect Vulnerability",
                                        description=f"Open redirect detected in parameter '{param}'",
                                        affected_url=url,
                                        affected_parameter=param,
                                        payload=payload,
                                        evidence=f"Redirect to: {location}",
                                        remediation="Validate redirect URLs against whitelist"
                                    )
                                    vulnerabilities.append(vuln)
                                    break
                                    
                    except Exception:
                        continue
        
        return vulnerabilities
    
    async def _test_exposed_endpoints(self, base_url: str) -> List[Vulnerability]:
        """Test for exposed sensitive endpoints"""
        vulnerabilities = []
        
        # Common sensitive endpoints
        sensitive_endpoints = [
            "/admin", "/admin/", "/administrator", "/manage",
            "/api", "/api/", "/rest", "/rest/",
            "/config", "/configuration", "/settings",
            "/backup", "/backups", "/db", "/database",
            "/logs", "/log", "/debug", "/test",
            "/phpinfo.php", "/info.php", "/server-status",
            "/.env", "/.git", "/.svn", "/.htaccess",
            "/robots.txt", "/sitemap.xml", "/crossdomain.xml"
        ]
        
        for endpoint in sensitive_endpoints:
            test_url = urljoin(base_url, endpoint)
            try:
                async with self.session.get(test_url) as response:
                    if response.status == 200:
                        vuln = Vulnerability(
                            type=VulnerabilityType.EXPOSED_ENDPOINTS,
                            severity=SeverityLevel.LOW,
                            title="Exposed Sensitive Endpoint",
                            description=f"Sensitive endpoint '{endpoint}' is accessible",
                            affected_url=test_url,
                            evidence=f"Endpoint returns status {response.status}",
                            remediation="Restrict access to sensitive endpoints"
                        )
                        vulnerabilities.append(vuln)
                        
            except Exception:
                continue
        
        return vulnerabilities
    
    async def _scan_ssl_vulnerabilities(self) -> None:
        """Scan for SSL/TLS vulnerabilities"""
        try:
            parsed_url = urlparse(self.config.target_url)
            hostname = parsed_url.hostname
            port = parsed_url.port or 443
            
            # Test SSL connection
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    if not_after < datetime.utcnow():
                        vuln = Vulnerability(
                            type=VulnerabilityType.WEAK_SSL,
                            severity=SeverityLevel.HIGH,
                            title="Expired SSL Certificate",
                            description="SSL certificate has expired",
                            affected_url=self.config.target_url,
                            evidence=f"Certificate expired on {not_after}",
                            remediation="Renew SSL certificate"
                        )
                        self.vulnerabilities.append(vuln)
                    
                    # Check certificate strength
                    cipher = ssock.cipher()
                    if cipher and cipher[0] in ['RC4', 'DES', '3DES']:
                        vuln = Vulnerability(
                            type=VulnerabilityType.WEAK_SSL,
                            severity=SeverityLevel.MEDIUM,
                            title="Weak SSL Cipher",
                            description="Weak SSL cipher suite is being used",
                            affected_url=self.config.target_url,
                            evidence=f"Weak cipher: {cipher[0]}",
                            remediation="Configure strong cipher suites"
                        )
                        self.vulnerabilities.append(vuln)
                        
        except Exception as e:
            vuln = Vulnerability(
                type=VulnerabilityType.WEAK_SSL,
                severity=SeverityLevel.MEDIUM,
                title="SSL Configuration Issue",
                description="SSL/TLS configuration issue detected",
                affected_url=self.config.target_url,
                evidence=str(e),
                remediation="Review SSL/TLS configuration"
            )
            self.vulnerabilities.append(vuln)
    
    async def _scan_default_credentials(self) -> None:
        """Scan for default credentials"""
        # Common default credentials
        default_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("root", "root"),
            ("root", "password"),
            ("user", "user"),
            ("guest", "guest"),
            ("test", "test")
        ]
        
        # Common admin endpoints
        admin_endpoints = ["/admin", "/login", "/administrator", "/manage"]
        
        for endpoint in admin_endpoints:
            login_url = urljoin(self.config.target_url, endpoint)
            
            for username, password in default_creds:
                try:
                    data = {"username": username, "password": password}
                    async with self.session.post(login_url, data=data) as response:
                        content = await response.text()
                        
                        # Check if login was successful
                        if "dashboard" in content.lower() or "welcome" in content.lower():
                            vuln = Vulnerability(
                                type=VulnerabilityType.DEFAULT_CREDENTIALS,
                                severity=SeverityLevel.CRITICAL,
                                title="Default Credentials",
                                description=f"Default credentials work: {username}:{password}",
                                affected_url=login_url,
                                evidence=f"Login successful with {username}:{password}",
                                remediation="Change default credentials immediately"
                            )
                            self.vulnerabilities.append(vuln)
                            break
                            
                except Exception:
                    continue
    
    def _extract_forms(self, content: str, base_url: str) -> List[Dict]:
        """Extract forms from HTML content"""
        forms = []
        
        # Simple form extraction regex
        form_pattern = r'<form[^>]*action=["\']([^"\']*)["\'][^>]*>(.*?)</form>'
        input_pattern = r'<input[^>]*name=["\']([^"\']*)["\'][^>]*>'
        
        for match in re.finditer(form_pattern, content, re.DOTALL | re.IGNORECASE):
            action = match.group(1)
            form_content = match.group(2)
            
            # Extract input fields
            fields = re.findall(input_pattern, form_content, re.IGNORECASE)
            
            forms.append({
                "action": urljoin(base_url, action),
                "fields": fields
            })
        
        return forms
    
    def _extract_parameters(self, url: str) -> List[str]:
        """Extract URL parameters"""
        parsed = urlparse(url)
        if parsed.query:
            return [param.split('=')[0] for param in parsed.query.split('&')]
        return []
    
    def _extract_urls(self, content: str, base_url: str) -> List[str]:
        """Extract URLs from HTML content"""
        urls = []
        
        # Extract href attributes
        href_pattern = r'href=["\']([^"\']*)["\']'
        for match in re.finditer(href_pattern, content, re.IGNORECASE):
            url = match.group(1)
            if url.startswith('/') or url.startswith('http'):
                full_url = urljoin(base_url, url)
                if full_url.startswith(self.config.target_url):
                    urls.append(full_url)
        
        return list(set(urls))
    
    def _inject_payload(self, url: str, parameter: str, payload: str) -> str:
        """Inject payload into URL parameter"""
        if '?' in url:
            return f"{url}&{parameter}={payload}"
        else:
            return f"{url}?{parameter}={payload}"
    
    def _detect_sql_error(self, content: str) -> bool:
        """Detect SQL error messages in response"""
        sql_errors = [
            "sql syntax",
            "mysql error",
            "oracle error",
            "postgresql error",
            "sql server error",
            "syntax error",
            "unclosed quotation mark",
            "quoted string not properly terminated"
        ]
        
        content_lower = content.lower()
        return any(error in content_lower for error in sql_errors)
    
    def _vulnerability_to_dict(self, vuln: Vulnerability) -> Dict[str, Any]:
        """Convert Vulnerability to dictionary"""
        return {
            "type": vuln.type.value,
            "severity": vuln.severity.value,
            "title": vuln.title,
            "description": vuln.description,
            "affected_url": vuln.affected_url,
            "affected_parameter": vuln.affected_parameter,
            "payload": vuln.payload,
            "evidence": vuln.evidence,
            "cve_id": vuln.cve_id,
            "cvss_score": vuln.cvss_score,
            "remediation": vuln.remediation,
            "discovered_at": vuln.discovered_at.isoformat() if vuln.discovered_at else None
        }
    
    def get_vulnerabilities_by_severity(self, severity: SeverityLevel) -> List[Vulnerability]:
        """Get vulnerabilities by severity level"""
        return [v for v in self.vulnerabilities if v.severity == severity]
    
    def get_critical_vulnerabilities(self) -> List[Vulnerability]:
        """Get critical vulnerabilities"""
        return self.get_vulnerabilities_by_severity(SeverityLevel.CRITICAL)
    
    def generate_report(self) -> str:
        """Generate vulnerability scan report"""
        report = f"Vulnerability Scan Report for {self.config.target_url}\n"
        report += "=" * 60 + "\n"
        report += f"Scan Duration: {self.scan_end_time - self.scan_start_time:.2f} seconds\n"
        report += f"URLs Scanned: {len(self.scanned_urls)}\n"
        report += f"Total Vulnerabilities: {len(self.vulnerabilities)}\n\n"
        
        # Group by severity
        for severity in [SeverityLevel.CRITICAL, SeverityLevel.HIGH, SeverityLevel.MEDIUM, SeverityLevel.LOW]:
            vulns = self.get_vulnerabilities_by_severity(severity)
            if vulns:
                report += f"{severity.value.upper()} Severity ({len(vulns)}):\n"
                report += "-" * 30 + "\n"
                for vuln in vulns:
                    report += f"• {vuln.title}\n"
                    report += f"  URL: {vuln.affected_url}\n"
                    if vuln.affected_parameter:
                        report += f"  Parameter: {vuln.affected_parameter}\n"
                    if vuln.evidence:
                        report += f"  Evidence: {vuln.evidence}\n"
                    report += f"  Remediation: {vuln.remediation}\n\n"
        
        return report

# Example usage
async def main():
    """Example usage of vulnerability scanner"""
    print("🔍 Vulnerability Scanner Example")
    
    # Create scan configuration
    config = ScanConfig(
        target_url="http://localhost:8000",
        scan_depth=2,
        max_concurrent=5,
        timeout=10.0,
        scan_types=[
            VulnerabilityType.SQL_INJECTION,
            VulnerabilityType.XSS,
            VulnerabilityType.OPEN_REDIRECT,
            VulnerabilityType.EXPOSED_ENDPOINTS
        ]
    )
    
    # Create scanner
    scanner = VulnerabilityScanner(config)
    
    # Perform scan
    print(f"Scanning {config.target_url} for vulnerabilities...")
    result = await scanner.scan_target()
    
    if result["success"]:
        print(f"✅ Scan completed in {result['scan_duration']:.2f} seconds")
        print(f"📊 Found {result['total_vulnerabilities']} vulnerabilities")
        print(f"🌐 Scanned {result['scanned_urls']} URLs")
        
        # Print critical vulnerabilities
        critical_vulns = scanner.get_critical_vulnerabilities()
        if critical_vulns:
            print(f"\n🚨 Critical Vulnerabilities ({len(critical_vulns)}):")
            for vuln in critical_vulns:
                print(f"  • {vuln.title}")
                print(f"    URL: {vuln.affected_url}")
                print(f"    Evidence: {vuln.evidence}")
        
        # Generate report
        print("\n📋 Vulnerability Report:")
        print(scanner.generate_report())
        
    else:
        print(f"❌ Scan failed: {result['error']}")

if __name__ == "__main__":
    asyncio.run(main()) 