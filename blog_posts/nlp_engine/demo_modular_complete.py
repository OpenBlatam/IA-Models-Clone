from typing_extensions import Literal, TypedDict
from typing import Any, List, Dict, Optional, Union, Tuple
# Constants
MAX_CONNECTIONS = 1000

# Constants
MAX_RETRIES = 100

# Constants
TIMEOUT_SECONDS = 60

import asyncio
import json
import time
from typing import Dict, List, Any, Optional, AsyncGenerator
import logging
from nlp_engine.core.entities import AnalysisResult, TextFingerprint, AnalysisScore
from nlp_engine.core.enums import AnalysisType, ProcessingTier, CacheStrategy, Environment
from nlp_engine.core.domain_services import AnalysisOrchestrator, TextProcessor, ScoreValidator
from nlp_engine.application.dto import AnalysisRequest, BatchAnalysisRequest
from nlp_engine.application.use_cases import AnalyzeTextUseCase, BatchAnalysisUseCase
from nlp_engine.application.services import AnalysisService, CacheService, MetricsService
from demo_infrastructure import (
        from nlp_engine.application.dto import HealthCheckRequest
from typing import Any, List, Dict, Optional
"""
üéØ DEMO MODULAR COMPLETE - Demostraci√≥n de Arquitectura Modular NLP
================================================================

Demostraci√≥n completa del sistema modular NLP con todas las capas:
- Core (Domain Logic, Entities, Domain Services)
- Interfaces (Ports & Contracts)
- Application (Use Cases, Services, DTOs)
- Infrastructure (Mock implementations)

Este demo muestra un sistema enterprise-grade completamente funcional.
"""


# Core Layer

# Application Layer

# Mock Infrastructure (for demo)
    MockAnalyzerFactory, MockCacheRepository, MockMetricsCollector,
    MockConfigurationService, MockStructuredLogger, MockPerformanceMonitor,
    MockHealthChecker, MockCacheKeyGenerator
)


class ModularNLPEngineDemo:
    """Demo completo del motor NLP modular."""
    
    def __init__(self) -> Any:
        self.logger = self._setup_logging()
        
        # Infrastructure Layer (Mock implementations for demo)
        self._setup_infrastructure()
        
        # Application Services
        self._setup_application_services()
        
        # Use Cases
        self._setup_use_cases()
        
        # Demo data
        self._setup_demo_data()
    
    def _setup_logging(self) -> logging.Logger:
        """Configurar logging para el demo."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        return logging.getLogger(self.__class__.__name__)
    
    def _setup_infrastructure(self) -> None:
        """Configurar capa de infraestructura (mocks para demo)."""
        self.analyzer_factory = MockAnalyzerFactory()
        self.cache_repository = MockCacheRepository()
        self.metrics_collector = MockMetricsCollector()
        self.config_service = MockConfigurationService()
        self.structured_logger = MockStructuredLogger()
        self.performance_monitor = MockPerformanceMonitor()
        self.health_checker = MockHealthChecker()
        self.cache_key_generator = MockCacheKeyGenerator()
    
    def _setup_application_services(self) -> None:
        """Configurar servicios de aplicaci√≥n."""
        # Analysis Service
        self.analysis_service = AnalysisService(
            config_service=self.config_service,
            metrics_collector=self.metrics_collector,
            cache_repository=self.cache_repository,
            performance_monitor=self.performance_monitor,
            health_checker=self.health_checker
        )
        
        # Cache Service
        self.cache_service = CacheService(
            cache_repository=self.cache_repository,
            cache_key_generator=self.cache_key_generator,
            metrics_collector=self.metrics_collector
        )
        
        # Metrics Service
        self.metrics_service = MetricsService(
            metrics_collector=self.metrics_collector,
            performance_monitor=self.performance_monitor,
            health_checker=self.health_checker
        )
    
    def _setup_use_cases(self) -> None:
        """Configurar casos de uso."""
        # Main Use Case
        self.analyze_text_use_case = AnalyzeTextUseCase(
            analyzer_factory=self.analyzer_factory,
            cache_repository=self.cache_repository,
            metrics_collector=self.metrics_collector,
            config_service=self.config_service,
            logger=self.structured_logger
        )
        
        # Batch Use Case
        self.batch_analysis_use_case = BatchAnalysisUseCase(
            analyze_text_use_case=self.analyze_text_use_case
        )
    
    def _setup_demo_data(self) -> None:
        """Configurar datos de prueba."""
        self.demo_texts = [
            "Este es un texto excelente con muy buena calidad y sentimiento positivo.",
            "El servicio fue terrible, muy mal, no lo recomiendo para nada.",
            "Un texto neutral sin emociones particulares, simplemente informativo.",
            "¬°Incre√≠ble experiencia! Lo mejor que he probado en mucho tiempo.",
            "No est√° mal, tampoco es excepcional, algo promedio en general.",
            "Texto muy corto.",
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur."
        ]
    
    async def run_complete_demo(self) -> Any:
        """Ejecutar demostraci√≥n completa del sistema modular."""
        print("üéØ DEMO MODULAR NLP ENGINE - Arquitectura Enterprise")
        print("=" * 60)
        
        # Inicializar sistema
        await self._demo_system_initialization()
        
        # Demo 1: An√°lisis individual
        await self._demo_individual_analysis()
        
        # Demo 2: An√°lisis en lote
        await self._demo_batch_analysis()
        
        # Demo 3: Performance y optimizaci√≥n
        await self._demo_performance_optimization()
        
        # Demo 4: Cache management
        await self._demo_cache_management()
        
        # Demo 5: M√©tricas y monitoreo
        await self._demo_metrics_monitoring()
        
        # Demo 6: Health checks
        await self._demo_health_checks()
        
        # Demo 7: Domain logic
        await self._demo_domain_logic()
        
        # Demo 8: Different tiers
        await self._demo_processing_tiers()
        
        # Resumen final
        await self._demo_final_summary()
    
    async def _demo_system_initialization(self) -> Any:
        """Demo de inicializaci√≥n del sistema."""
        print("\nüöÄ 1. INICIALIZACI√ìN DEL SISTEMA")
        print("-" * 40)
        
        try:
            await self.analysis_service.initialize()
            print("‚úÖ Sistema inicializado correctamente")
            
            # Validar configuraci√≥n
            config_errors = self.config_service.validate_config()
            if not config_errors:
                print("‚úÖ Configuraci√≥n validada")
            else:
                print(f"‚ö†Ô∏è  Errores de configuraci√≥n: {config_errors}")
            
            # Mostrar configuraci√≥n actual
            current_tier = self.analysis_service.get_default_tier()
            cache_strategy = self.analysis_service.get_cache_strategy()
            
            print(f"üìä Tier por defecto: {current_tier.value}")
            print(f"üóÑÔ∏è  Estrategia de cache: {cache_strategy.value}")
            
        except Exception as e:
            print(f"‚ùå Error en inicializaci√≥n: {e}")
    
    async def _demo_individual_analysis(self) -> Any:
        """Demo de an√°lisis individual."""
        print("\nüìù 2. AN√ÅLISIS INDIVIDUAL DE TEXTO")
        print("-" * 40)
        
        text = self.demo_texts[0]
        print(f"Texto: '{text[:50]}...'")
        
        # Crear request
        request = AnalysisRequest(
            text=text,
            analysis_types=[AnalysisType.SENTIMENT, AnalysisType.QUALITY_ASSESSMENT],
            processing_tier=ProcessingTier.BALANCED,
            client_id="demo_client",
            use_cache=True
        )
        
        try:
            # Ejecutar an√°lisis
            start_time = time.time()
            response = await self.analyze_text_use_case.execute(request)
            duration = (time.time() - start_time) * 1000
            
            print(f"‚è±Ô∏è  Duraci√≥n: {duration:.2f}ms")
            print(f"‚úÖ √âxito: {response.success}")
            print(f"üÜî Request ID: {response.request_id}")
            
            if response.success:
                results = response.analysis_results
                print("üìä Resultados:")
                
                for analysis_type, score_data in results.get('scores', {}).items():
                    print(f"  - {analysis_type}: {score_data.get('value', 0):.2f} "
                          f"(confianza: {score_data.get('confidence', 0):.2f})")
                
                metadata = response.metadata
                print(f"üéØ Performance Grade: {metadata.get('performance_grade', 'N/A')}")
                print(f"üóÑÔ∏è  Cache Hit: {metadata.get('cache_hit', False)}")
            else:
                print(f"‚ùå Errores: {response.errors}")
                
        except Exception as e:
            print(f"‚ùå Error en an√°lisis: {e}")
    
    async def _demo_batch_analysis(self) -> Any:
        """Demo de an√°lisis en lote."""
        print("\nüìã 3. AN√ÅLISIS EN LOTE")
        print("-" * 40)
        
        batch_texts = self.demo_texts[:5]
        print(f"Analizando {len(batch_texts)} textos en paralelo...")
        
        # Crear request de lote
        batch_request = BatchAnalysisRequest(
            texts=batch_texts,
            analysis_types=[AnalysisType.SENTIMENT],
            processing_tier=ProcessingTier.ULTRA_FAST,
            max_concurrency=3,
            client_id="batch_demo"
        )
        
        try:
            start_time = time.time()
            responses = await self.batch_analysis_use_case.execute(batch_request)
            duration = (time.time() - start_time) * 1000
            
            print(f"‚è±Ô∏è  Duraci√≥n total: {duration:.2f}ms")
            print(f"üìä Resultados procesados: {len(responses)}")
            
            successful = sum(1 for r in responses if r.success)
            failed = len(responses) - successful
            
            print(f"‚úÖ Exitosos: {successful}")
            print(f"‚ùå Fallidos: {failed}")
            
            # Mostrar algunos resultados
            print("\nüìà Muestra de resultados:")
            for i, response in enumerate(responses[:3]):
                if response.success:
                    sentiment_score = response.analysis_results.get('scores', {}).get('SENTIMENT', {})
                    print(f"  Texto {i+1}: Sentimiento = {sentiment_score.get('value', 0):.2f}")
                    
        except Exception as e:
            print(f"‚ùå Error en an√°lisis en lote: {e}")
    
    async def _demo_performance_optimization(self) -> Any:
        """Demo de optimizaci√≥n de performance."""
        print("\n‚ö° 4. OPTIMIZACI√ìN DE PERFORMANCE")
        print("-" * 40)
        
        print("Ejecutando m√∫ltiples an√°lisis para generar m√©tricas...")
        
        # Ejecutar varios an√°lisis r√°pidos
        tasks = []
        for i in range(10):
            text = self.demo_texts[i % len(self.demo_texts)]
            request = AnalysisRequest(
                text=text,
                analysis_types=[AnalysisType.SENTIMENT],
                processing_tier=ProcessingTier.ULTRA_FAST
            )
            tasks.append(self.analyze_text_use_case.execute(request))
        
        start_time = time.time()
        results = await asyncio.gather(*tasks, return_exceptions=True)
        total_duration = (time.time() - start_time) * 1000
        
        successful_results = [r for r in results if not isinstance(r, Exception) and r.success]
        
        print(f"üìä An√°lisis completados: {len(successful_results)}/10")
        print(f"‚è±Ô∏è  Tiempo total: {total_duration:.2f}ms")
        print(f"‚ö° Promedio por an√°lisis: {total_duration/10:.2f}ms")
        print(f"üöÄ Throughput: {10000/total_duration:.1f} an√°lisis/segundo")
        
        # Obtener m√©tricas de performance
        performance_summary = self.metrics_service.get_performance_summary()
        print(f"üíæ Memoria: {performance_summary.get('memory_usage', {}).get('used_mb', 0):.1f}MB")
        print(f"üñ•Ô∏è  CPU: {performance_summary.get('cpu_usage', 0):.1f}%")
    
    async def _demo_cache_management(self) -> Any:
        """Demo de gesti√≥n de cache."""
        print("\nüóÑÔ∏è  5. GESTI√ìN DE CACHE")
        print("-" * 40)
        
        # Obtener estad√≠sticas de cache
        cache_stats = self.cache_service.get_cache_stats()
        print(f"üìà Estad√≠sticas de Cache:")
        print(f"  - Hits: {cache_stats['hits']}")
        print(f"  - Misses: {cache_stats['misses']}")
        print(f"  - Hit Rate: {cache_stats['hit_rate']:.2%}")
        print(f"  - Total Requests: {cache_stats['total_requests']}")
        
        # Optimizar cache
        print("\nüîß Optimizando cache...")
        optimization_result = await self.cache_service.optimize_cache()
        
        if optimization_result['success']:
            print("‚úÖ Optimizaci√≥n completada")
            optimizations = optimization_result.get('optimizations', [])
            if optimizations:
                print(f"   Optimizaciones realizadas: {', '.join(optimizations)}")
            else:
                print("   No se requirieron optimizaciones")
        else:
            print(f"‚ùå Error en optimizaci√≥n: {optimization_result.get('error')}")
    
    async def _demo_metrics_monitoring(self) -> Any:
        """Demo de m√©tricas y monitoreo."""
        print("\nüìä 6. M√âTRICAS Y MONITOREO")
        print("-" * 40)
        
        # Generar reporte de performance
        performance_report = await self.metrics_service.generate_performance_report()
        
        if 'error' not in performance_report:
            summary = performance_report.get('summary', {})
            print(f"üéØ Estado General: {summary.get('overall_status', 'unknown')}")
            print(f"üìù Total de Requests: {summary.get('total_requests', 0)}")
            print(f"‚è±Ô∏è  Latencia Promedio: {summary.get('avg_latency', 0):.2f}ms")
            print(f"üóÑÔ∏è  Cache Hit Rate: {summary.get('cache_hit_rate', 0):.2%}")
            
            # M√©tricas detalladas
            metrics = performance_report.get('metrics', {})
            print("\nüìà M√©tricas Detalladas:")
            for metric_name, value in metrics.items():
                if isinstance(value, (int, float)):
                    print(f"  - {metric_name}: {value}")
        else:
            print(f"‚ùå Error obteniendo m√©tricas: {performance_report['error']}")
    
    async def _demo_health_checks(self) -> Any:
        """Demo de health checks."""
        print("\nüè• 7. HEALTH CHECKS")
        print("-" * 40)
        
        
        # Health check completo del sistema
        health_request = HealthCheckRequest(
            deep_check=True,
            include_metrics=True
        )
        
        health_response = await self.metrics_service.handle_health_check_request(health_request)
        
        print(f"üéØ Estado del Sistema: {health_response.status}")
        print(f"‚è∞ Uptime: {health_response.uptime_seconds:.1f} segundos")
        
        # Componentes
        if health_response.components:
            print("\nüîß Estado de Componentes:")
            for component, status in health_response.components.items():
                comp_status = status.get('status', 'unknown')
                print(f"  - {component}: {comp_status}")
        
        # Errores si los hay
        if health_response.errors:
            print(f"\n‚ö†Ô∏è  Errores: {health_response.errors}")
    
    async def _demo_domain_logic(self) -> Any:
        """Demo de l√≥gica de dominio."""
        print("\nüèóÔ∏è  8. L√ìGICA DE DOMINIO")
        print("-" * 40)
        
        # Text Processor
        text_processor = TextProcessor()
        raw_text = "  ¬°¬°¬°Texto con MUCHOS espacios   y s√≠mbolos!!!  "
        sanitized = text_processor.sanitize_text(raw_text)
        print(f"üßπ Texto sanitizado: '{sanitized}'")
        
        # Text Fingerprint
        fingerprint = TextFingerprint.create(sanitized)
        print(f"üîç Fingerprint: {fingerprint.short_hash}")
        print(f"üìè Longitud: {fingerprint.length}")
        
        # Score Validator
        score_validator = ScoreValidator()
        test_score = 85.5
        is_valid_sentiment = score_validator.validate_sentiment_score(test_score, "transformer")
        print(f"‚úÖ Score {test_score} v√°lido para sentimiento: {is_valid_sentiment}")
        
        # Analysis Orchestrator
        orchestrator = AnalysisOrchestrator()
        optimal_tier = orchestrator.determine_optimal_tier(
            text_length=len(sanitized),
            analysis_types=[AnalysisType.SENTIMENT, AnalysisType.QUALITY_ASSESSMENT]
        )
        print(f"üéØ Tier √≥ptimo determinado: {optimal_tier.value}")
    
    async def _demo_processing_tiers(self) -> Any:
        """Demo de diferentes tiers de procesamiento."""
        print("\n‚öôÔ∏è  9. TIERS DE PROCESAMIENTO")
        print("-" * 40)
        
        text = self.demo_texts[0]
        tiers = [ProcessingTier.ULTRA_FAST, ProcessingTier.BALANCED, ProcessingTier.HIGH_QUALITY]
        
        for tier in tiers:
            print(f"\nüîß Probando tier: {tier.value}")
            
            request = AnalysisRequest(
                text=text,
                analysis_types=[AnalysisType.SENTIMENT],
                processing_tier=tier,
                use_cache=False  # Sin cache para medir tiempo real
            )
            
            start_time = time.time()
            response = await self.analyze_text_use_case.execute(request)
            duration = (time.time() - start_time) * 1000
            
            if response.success:
                sentiment = response.analysis_results.get('scores', {}).get('SENTIMENT', {})
                score = sentiment.get('value', 0)
                confidence = sentiment.get('confidence', 0)
                
                print(f"  ‚è±Ô∏è  Duraci√≥n: {duration:.2f}ms")
                print(f"  üìä Score: {score:.2f} (confianza: {confidence:.2f})")
                print(f"  üéØ Grade: {response.metadata.get('performance_grade', 'N/A')}")
            else:
                print(f"  ‚ùå Error: {response.errors}")
    
    async def _demo_final_summary(self) -> Any:
        """Resumen final del demo."""
        print("\nüéâ 10. RESUMEN FINAL")
        print("-" * 40)
        
        # Estad√≠sticas finales
        final_performance = await self.metrics_service.generate_performance_report()
        
        if 'error' not in final_performance:
            summary = final_performance.get('summary', {})
            metrics = final_performance.get('metrics', {})
            
            print("üìä ESTAD√çSTICAS FINALES:")
            print(f"  üéØ Estado: {summary.get('overall_status', 'unknown')}")
            print(f"  üìù Total An√°lisis: {summary.get('total_requests', 0)}")
            print(f"  ‚è±Ô∏è  Latencia Promedio: {summary.get('avg_latency', 0):.2f}ms")
            print(f"  üóÑÔ∏è  Cache Hit Rate: {summary.get('cache_hit_rate', 0):.2%}")
            
            print("\nüèóÔ∏è  ARQUITECTURA MODULAR:")
            print("  ‚úÖ Core Layer: Entities, Value Objects, Domain Services")
            print("  ‚úÖ Interfaces Layer: Ports & Contracts")
            print("  ‚úÖ Application Layer: Use Cases, Services, DTOs")
            print("  ‚úÖ Infrastructure Layer: Mock implementations")
            
            print("\nüöÄ CARACTER√çSTICAS ENTERPRISE:")
            print("  ‚úÖ Clean Architecture")
            print("  ‚úÖ SOLID Principles")
            print("  ‚úÖ Dependency Injection")
            print("  ‚úÖ Async/Await Pattern")
            print("  ‚úÖ Comprehensive Error Handling")
            print("  ‚úÖ Performance Monitoring")
            print("  ‚úÖ Health Checks")
            print("  ‚úÖ Cache Management")
            print("  ‚úÖ Structured Logging")
            print("  ‚úÖ Multiple Processing Tiers")
            
        # Cleanup
        try:
            await self.analysis_service.shutdown()
            print("\n‚úÖ Sistema cerrado correctamente")
        except Exception as e:
            print(f"\n‚ö†Ô∏è  Error en cierre: {e}")


async def main():
    """Funci√≥n principal del demo."""
    demo = ModularNLPEngineDemo()
    await demo.run_complete_demo()


match __name__:
    case "__main__":
    asyncio.run(main()) 