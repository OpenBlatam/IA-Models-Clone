"""
⚙️ Configuration Manager

Centralized configuration management system using YAML files.
Implements the key convention: "Use configuration files (e.g., YAML) for hyperparameters and model settings."
"""

import os
import yaml
from typing import Any, Dict, List, Optional, Union, Type
from pathlib import Path
import logging
from dataclasses import dataclass, asdict, fields
import json
from copy import deepcopy

logger = logging.getLogger(__name__)


class ConfigManager:
    """
    Centralized configuration manager for YAML-based configurations.
    
    Features:
    - YAML file loading and saving
    - Environment variable substitution
    - Configuration validation
    - Hierarchical configuration merging
    - Environment-specific overrides
    """
    
    def __init__(self, config_dir: Union[str, Path] = "configs"):
        """
        Initialize the configuration manager.
        
        Args:
            config_dir: Directory containing configuration files
        """
        self.config_dir = Path(config_dir)
        self.config_dir.mkdir(exist_ok=True)
        self.loaded_configs = {}
        
        logger.info(f"Configuration manager initialized with directory: {self.config_dir}")
    
    def load_yaml(self, config_path: Union[str, Path]) -> Dict[str, Any]:
        """
        Load configuration from YAML file with environment variable substitution.
        
        Args:
            config_path: Path to YAML configuration file
            
        Returns:
            Dictionary containing configuration
        """
        config_path = Path(config_path)
        
        if not config_path.is_absolute():
            config_path = self.config_dir / config_path
        
        if not config_path.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_path}")
        
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Substitute environment variables
            content = self._substitute_environment_variables(content)
            
            # Load YAML
            config = yaml.safe_load(content)
            
            logger.info(f"Configuration loaded from: {config_path}")
            return config
            
        except yaml.YAMLError as e:
            logger.error(f"YAML parsing error in {config_path}: {e}")
            raise
        except Exception as e:
            logger.error(f"Error loading configuration from {config_path}: {e}")
            raise
    
    def save_yaml(self, config: Dict[str, Any], config_path: Union[str, Path], 
                  add_comments: bool = True) -> None:
        """
        Save configuration to YAML file.
        
        Args:
            config: Configuration dictionary to save
            config_path: Path to save the configuration
            add_comments: Whether to add helpful comments
        """
        config_path = Path(config_path)
        
        if not config_path.is_absolute():
            config_path = self.config_dir / config_path
        
        config_path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            # Convert dataclass objects to dictionaries
            serializable_config = self._make_serializable(config)
            
            with open(config_path, 'w', encoding='utf-8') as f:
                if add_comments:
                    f.write(f"# Configuration file generated by ConfigManager\n")
                    f.write(f"# File: {config_path.name}\n")
                    f.write(f"# Generated at: {self._get_timestamp()}\n\n")
                
                yaml.dump(serializable_config, f, default_flow_style=False, 
                         indent=2, sort_keys=False, allow_unicode=True)
            
            logger.info(f"Configuration saved to: {config_path}")
            
        except Exception as e:
            logger.error(f"Error saving configuration to {config_path}: {e}")
            raise
    
    def load_config_class(self, config_class: Type, config_path: Union[str, Path]) -> Any:
        """
        Load configuration into a specific configuration class.
        
        Args:
            config_class: Configuration class (dataclass) to instantiate
            config_path: Path to YAML configuration file
            
        Returns:
            Instance of the configuration class
        """
        config_dict = self.load_yaml(config_path)
        
        try:
            # Create instance with loaded configuration
            config_instance = self._dict_to_dataclass(config_dict, config_class)
            
            logger.info(f"Configuration loaded into {config_class.__name__}")
            return config_instance
            
        except Exception as e:
            logger.error(f"Error creating {config_class.__name__} from {config_path}: {e}")
            raise
    
    def save_config_class(self, config_instance: Any, config_path: Union[str, Path]) -> None:
        """
        Save configuration class instance to YAML file.
        
        Args:
            config_instance: Configuration class instance (dataclass)
            config_path: Path to save the configuration
        """
        try:
            # Convert dataclass to dictionary
            config_dict = asdict(config_instance)
            
            # Save to YAML
            self.save_yaml(config_dict, config_path)
            
            logger.info(f"Configuration {type(config_instance).__name__} saved to: {config_path}")
            
        except Exception as e:
            logger.error(f"Error saving configuration class to {config_path}: {e}")
            raise
    
    def merge_configs(self, base_config: Dict[str, Any], 
                     override_config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Merge two configurations with deep merging.
        
        Args:
            base_config: Base configuration dictionary
            override_config: Configuration to merge in (takes precedence)
            
        Returns:
            Merged configuration dictionary
        """
        merged = deepcopy(base_config)
        
        def deep_merge(base: Dict, override: Dict) -> Dict:
            for key, value in override.items():
                if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                    base[key] = deep_merge(base[key], value)
                else:
                    base[key] = value
            return base
        
        return deep_merge(merged, override_config)
    
    def load_environment_config(self, base_config_path: Union[str, Path], 
                               environment: str = None) -> Dict[str, Any]:
        """
        Load configuration with environment-specific overrides.
        
        Args:
            base_config_path: Path to base configuration file
            environment: Environment name (dev, staging, prod)
            
        Returns:
            Configuration with environment overrides applied
        """
        # Load base configuration
        base_config = self.load_yaml(base_config_path)
        
        # Determine environment
        if environment is None:
            environment = os.getenv('ML_ENVIRONMENT', 'dev')
        
        # Try to load environment-specific overrides
        base_path = Path(base_config_path)
        env_config_path = base_path.parent / f"{base_path.stem}_{environment}.yaml"
        
        if env_config_path.exists():
            env_config = self.load_yaml(env_config_path)
            merged_config = self.merge_configs(base_config, env_config)
            logger.info(f"Applied environment overrides for: {environment}")
            return merged_config
        else:
            logger.info(f"No environment overrides found for: {environment}")
            return base_config
    
    def validate_config(self, config: Dict[str, Any], 
                       required_keys: List[str] = None) -> bool:
        """
        Validate configuration dictionary.
        
        Args:
            config: Configuration to validate
            required_keys: List of required keys
            
        Returns:
            True if configuration is valid
        """
        if required_keys:
            missing_keys = [key for key in required_keys if key not in config]
            if missing_keys:
                logger.error(f"Missing required configuration keys: {missing_keys}")
                return False
        
        logger.info("Configuration validation passed")
        return True
    
    def get_config_summary(self, config: Dict[str, Any]) -> str:
        """
        Generate a summary of the configuration.
        
        Args:
            config: Configuration to summarize
            
        Returns:
            String summary of the configuration
        """
        def summarize_dict(d: Dict, indent: int = 0) -> str:
            summary = ""
            prefix = "  " * indent
            
            for key, value in d.items():
                if isinstance(value, dict):
                    summary += f"{prefix}{key}:\n"
                    summary += summarize_dict(value, indent + 1)
                elif isinstance(value, list):
                    summary += f"{prefix}{key}: [{len(value)} items]\n"
                else:
                    summary += f"{prefix}{key}: {value}\n"
            
            return summary
        
        return f"Configuration Summary:\n{summarize_dict(config)}"
    
    def _substitute_environment_variables(self, content: str) -> str:
        """Substitute environment variables in YAML content."""
        import re
        
        # Pattern to match ${VAR_NAME} or ${VAR_NAME:default_value}
        pattern = r'\$\{([^}:]+)(?::([^}]*))?\}'
        
        def replace_env_var(match):
            var_name = match.group(1)
            default_value = match.group(2) if match.group(2) is not None else ""
            return os.getenv(var_name, default_value)
        
        return re.sub(pattern, replace_env_var, content)
    
    def _make_serializable(self, obj: Any) -> Any:
        """Convert objects to JSON-serializable format."""
        if hasattr(obj, '__dict__'):
            # Convert dataclass or object to dict
            if hasattr(obj, '__dataclass_fields__'):
                return asdict(obj)
            else:
                return obj.__dict__
        elif isinstance(obj, dict):
            return {k: self._make_serializable(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._make_serializable(item) for item in obj]
        elif isinstance(obj, (Path,)):
            return str(obj)
        else:
            return obj
    
    def _dict_to_dataclass(self, config_dict: Dict[str, Any], config_class: Type) -> Any:
        """Convert dictionary to dataclass instance."""
        # Get field names and types from dataclass
        field_names = {field.name for field in fields(config_class)}
        
        # Filter dictionary to only include valid fields
        filtered_dict = {k: v for k, v in config_dict.items() if k in field_names}
        
        # Create instance
        return config_class(**filtered_dict)
    
    def _get_timestamp(self) -> str:
        """Get current timestamp as string."""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def list_configs(self) -> List[str]:
        """
        List all YAML configuration files in the config directory.
        
        Returns:
            List of configuration file names
        """
        yaml_files = []
        for file_path in self.config_dir.rglob("*.yaml"):
            yaml_files.append(str(file_path.relative_to(self.config_dir)))
        for file_path in self.config_dir.rglob("*.yml"):
            yaml_files.append(str(file_path.relative_to(self.config_dir)))
        
        return sorted(yaml_files)
    
    def backup_config(self, config_path: Union[str, Path]) -> Path:
        """
        Create a backup of a configuration file.
        
        Args:
            config_path: Path to configuration file to backup
            
        Returns:
            Path to the backup file
        """
        config_path = Path(config_path)
        if not config_path.is_absolute():
            config_path = self.config_dir / config_path
        
        backup_path = config_path.with_suffix(f"{config_path.suffix}.backup")
        
        import shutil
        shutil.copy2(config_path, backup_path)
        
        logger.info(f"Configuration backed up to: {backup_path}")
        return backup_path






