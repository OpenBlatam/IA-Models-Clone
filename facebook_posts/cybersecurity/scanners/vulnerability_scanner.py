from typing_extensions import Literal, TypedDict
from typing import Any, List, Dict, Optional, Union, Tuple
# Constants
BUFFER_SIZE = 1024

import asyncio
import socket
import ssl
import time
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
import re
import json
import hashlib
from concurrent.futures import ThreadPoolExecutor
from ..core import BaseConfig, ScanResult, BaseScanner
        import aiohttp
from typing import Any, List, Dict, Optional
import logging
"""
Vulnerability scanning utilities with proper async/def distinction.
Async for network operations, def for CPU-bound analysis.
"""



@dataclass
class VulnerabilityConfig(BaseConfig):
    """Configuration for vulnerability scanning."""
    timeout: float = 10.0
    max_workers: int = 50
    scan_depth: str = "medium"  # low, medium, high
    include_ssl_vulns: bool = True
    include_web_vulns: bool = True
    include_network_vulns: bool = True
    custom_signatures: List[str] = None

@dataclass
class VulnerabilityResult(ScanResult):
    """Result of vulnerability scan."""
    vulnerability_type: str
    severity: str  # low, medium, high, critical
    description: str
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    affected_component: str
    remediation: Optional[str] = None
    evidence: Optional[str] = None

def get_vulnerability_signatures() -> Dict[str, List[Dict[str, Any]]]:
    """Get vulnerability detection signatures."""
    return {
        "ssl_tls": [
            {
                "name": "Weak Cipher Suite",
                "pattern": r"(RC4|DES|3DES|MD5)",
                "severity": "high",
                "description": "Weak cipher suite detected"
            },
            {
                "name": "SSLv3 Support",
                "pattern": r"SSLv3",
                "severity": "high",
                "description": "SSLv3 is vulnerable to POODLE attack"
            },
            {
                "name": "TLS 1.0 Support",
                "pattern": r"TLSv1\.0",
                "severity": "medium",
                "description": "TLS 1.0 is deprecated"
            }
        ],
        "web": [
            {
                "name": "SQL Injection",
                "pattern": r"(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)",
                "severity": "critical",
                "description": "Potential SQL injection vulnerability"
            },
            {
                "name": "XSS",
                "pattern": r"<script[^>]*>.*?</script>",
                "severity": "high",
                "description": "Cross-site scripting vulnerability"
            },
            {
                "name": "Directory Traversal",
                "pattern": r"\.\./|\.\.\\",
                "severity": "high",
                "description": "Directory traversal vulnerability"
            }
        ],
        "network": [
            {
                "name": "Open Telnet",
                "port": 23,
                "severity": "high",
                "description": "Telnet service is unencrypted"
            },
            {
                "name": "Open FTP",
                "port": 21,
                "severity": "medium",
                "description": "FTP service may be unencrypted"
            },
            {
                "name": "Default SSH",
                "pattern": r"OpenSSH.*default",
                "severity": "medium",
                "description": "Default SSH configuration detected"
            }
        ]
    }

def analyze_ssl_vulnerabilities(ssl_info: Dict[str, Any]) -> List[VulnerabilityResult]:
    """Analyze SSL/TLS configuration for vulnerabilities."""
    vulnerabilities = []
    signatures = get_vulnerability_signatures()["ssl_tls"]
    
    # Check cipher suites
    if "cipher" in ssl_info:
        cipher_info = str(ssl_info["cipher"])
        for sig in signatures:
            if re.search(sig["pattern"], cipher_info, re.IGNORECASE):
                vulnerabilities.append(VulnerabilityResult(
                    target=ssl_info.get("host", "unknown"),
                    vulnerability_type="ssl_tls",
                    severity=sig["severity"],
                    description=sig["description"],
                    affected_component="cipher_suite",
                    evidence=cipher_info
                ))
    
    # Check certificate validity
    if "certificate" in ssl_info:
        cert = ssl_info["certificate"]
        if cert:
            # Check expiration
            if "notAfter" in cert:
                # This would typically check if certificate is expired or expiring soon
                pass
            
            # Check signature algorithm
            if "signature_algorithm" in cert:
                sig_algo = cert["signature_algorithm"]
                if "md5" in sig_algo.lower():
                    vulnerabilities.append(VulnerabilityResult(
                        target=ssl_info.get("host", "unknown"),
                        vulnerability_type="ssl_tls",
                        severity="high",
                        description="MD5 signature algorithm is weak",
                        affected_component="certificate",
                        evidence=sig_algo
                    ))
    
    return vulnerabilities

def analyze_web_vulnerabilities(response_data: str, url: str) -> List[VulnerabilityResult]:
    """Analyze web response for vulnerabilities."""
    vulnerabilities = []
    signatures = get_vulnerability_signatures()["web"]
    
    for sig in signatures:
        if re.search(sig["pattern"], response_data, re.IGNORECASE):
            vulnerabilities.append(VulnerabilityResult(
                target=url,
                vulnerability_type="web",
                severity=sig["severity"],
                description=sig["description"],
                affected_component="web_application",
                evidence=response_data[:200] + "..." if len(response_data) > 200 else response_data
            ))
    
    return vulnerabilities

def analyze_network_vulnerabilities(port_info: Dict[str, Any]) -> List[VulnerabilityResult]:
    """Analyze network configuration for vulnerabilities."""
    vulnerabilities = []
    signatures = get_vulnerability_signatures()["network"]
    
    for sig in signatures:
        if "port" in sig and port_info.get("port") == sig["port"]:
            vulnerabilities.append(VulnerabilityResult(
                target=port_info.get("host", "unknown"),
                vulnerability_type="network",
                severity=sig["severity"],
                description=sig["description"],
                affected_component=f"port_{sig['port']}",
                evidence=f"Port {sig['port']} is open"
            ))
    
    return vulnerabilities

async def scan_ssl_vulnerabilities(host: str, port: int = 443, config: VulnerabilityConfig = None) -> List[VulnerabilityResult]:
    """Scan for SSL/TLS vulnerabilities asynchronously."""
    if config is None:
        config = VulnerabilityConfig()
    
    try:
        context = ssl.create_default_context()
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(config.timeout)
        
        with context.wrap_socket(sock, server_hostname=host) as ssock:
            ssock.connect((host, port))
            cert = ssock.getpeercert()
            
            ssl_info = {
                "host": host,
                "port": port,
                "cipher": ssock.cipher(),
                "certificate": cert,
                "version": ssock.version()
            }
            
            return analyze_ssl_vulnerabilities(ssl_info)
            
    except Exception as e:
        return [VulnerabilityResult(
            target=host,
            vulnerability_type="ssl_tls",
            severity="info",
            description=f"SSL scan failed: {str(e)}",
            affected_component="ssl_connection",
            evidence=str(e)
        )]

async def scan_web_vulnerabilities(url: str, config: VulnerabilityConfig = None) -> List[VulnerabilityResult]:
    """Scan web application for vulnerabilities asynchronously."""
    if config is None:
        config = VulnerabilityConfig()
    
    try:
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=config.timeout)) as session:
            async with session.get(url) as response:
                content = await response.text()
                
                # Check for common vulnerabilities
                vulnerabilities = analyze_web_vulnerabilities(content, url)
                
                # Check response headers for security issues
                headers = dict(response.headers)
                
                # Check for missing security headers
                security_headers = [
                    'strict-transport-security',
                    'content-security-policy',
                    'x-frame-options',
                    'x-content-type-options',
                    'x-xss-protection'
                ]
                
                missing_headers = [h for h in security_headers if h not in headers]
                if missing_headers:
                    vulnerabilities.append(VulnerabilityResult(
                        target=url,
                        vulnerability_type="web",
                        severity="medium",
                        description=f"Missing security headers: {', '.join(missing_headers)}",
                        affected_component="http_headers",
                        evidence=f"Headers: {list(headers.keys())}"
                    ))
                
                return vulnerabilities
                
    except Exception as e:
        return [VulnerabilityResult(
            target=url,
            vulnerability_type="web",
            severity="info",
            description=f"Web scan failed: {str(e)}",
            affected_component="web_connection",
            evidence=str(e)
        )]

async def scan_network_vulnerabilities(host: str, ports: List[int], config: VulnerabilityConfig = None) -> List[VulnerabilityResult]:
    """Scan network for vulnerabilities asynchronously."""
    if config is None:
        config = VulnerabilityConfig()
    
    vulnerabilities = []
    
    for port in ports:
        try:
            # Check if port is open
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(config.timeout)
            result = sock.connect_ex((host, port))
            
            if result == 0:
                port_info = {
                    "host": host,
                    "port": port,
                    "is_open": True
                }
                
                # Analyze for vulnerabilities
                port_vulns = analyze_network_vulnerabilities(port_info)
                vulnerabilities.extend(port_vulns)
                
                # Try to grab banner for additional analysis
                try:
                    sock.send(b'\r\n')
                    banner = sock.recv(1024).decode('utf-8', errors='ignore')
                    
                    # Check banner for vulnerabilities
                    for sig in get_vulnerability_signatures()["network"]:
                        if "pattern" in sig and re.search(sig["pattern"], banner, re.IGNORECASE):
                            vulnerabilities.append(VulnerabilityResult(
                                target=host,
                                vulnerability_type="network",
                                severity=sig["severity"],
                                description=sig["description"],
                                affected_component=f"port_{port}",
                                evidence=banner[:200] + "..." if len(banner) > 200 else banner
                            ))
                except:
                    pass
            
            sock.close()
            
        except Exception as e:
            vulnerabilities.append(VulnerabilityResult(
                target=host,
                vulnerability_type="network",
                severity="info",
                description=f"Network scan failed for port {port}: {str(e)}",
                affected_component=f"port_{port}",
                evidence=str(e)
            ))
    
    return vulnerabilities

async def comprehensive_vulnerability_scan(host: str, config: VulnerabilityConfig = None) -> Dict[str, Any]:
    """Perform comprehensive vulnerability scan."""
    if config is None:
        config = VulnerabilityConfig()
    
    results = {
        "host": host,
        "scan_timestamp": time.time(),
        "vulnerabilities": [],
        "summary": {}
    }
    
    # SSL/TLS vulnerabilities
    if config.include_ssl_vulns:
        ssl_vulns = await scan_ssl_vulnerabilities(host, 443, config)
        results["vulnerabilities"].extend(ssl_vulns)
    
    # Web vulnerabilities
    if config.include_web_vulns:
        web_urls = [f"https://{host}", f"http://{host}"]
        for url in web_urls:
            web_vulns = await scan_web_vulnerabilities(url, config)
            results["vulnerabilities"].extend(web_vulns)
    
    # Network vulnerabilities
    if config.include_network_vulns:
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 5432, 8080]
        network_vulns = await scan_network_vulnerabilities(host, common_ports, config)
        results["vulnerabilities"].extend(network_vulns)
    
    # Generate summary
    severity_counts = {"low": 0, "medium": 0, "high": 0, "critical": 0}
    type_counts = {}
    
    for vuln in results["vulnerabilities"]:
        severity_counts[vuln.severity] += 1
        vuln_type = vuln.vulnerability_type
        type_counts[vuln_type] = type_counts.get(vuln_type, 0) + 1
    
    results["summary"] = {
        "total_vulnerabilities": len(results["vulnerabilities"]),
        "severity_distribution": severity_counts,
        "type_distribution": type_counts,
        "risk_score": calculate_risk_score(results["vulnerabilities"])
    }
    
    return results

def calculate_risk_score(vulnerabilities: List[VulnerabilityResult]) -> float:
    """Calculate overall risk score based on vulnerabilities."""
    if not vulnerabilities:
        return 0.0
    
    severity_weights = {
        "low": 1.0,
        "medium": 3.0,
        "high": 7.0,
        "critical": 10.0
    }
    
    total_score = sum(severity_weights.get(v.severity, 0) for v in vulnerabilities)
    return min(10.0, total_score / len(vulnerabilities))

class VulnerabilityScanner(BaseScanner):
    """Vulnerability scanner with advanced features."""
    
    def __init__(self, config: VulnerabilityConfig):
        
    """__init__ function."""
super().__init__(config)
        self.config = config
    
    async def scan_target(self, target: str) -> Dict[str, Any]:
        """Scan a single target for vulnerabilities."""
        self.logger.info(f"Starting vulnerability scan of {target}")
        
        return await comprehensive_vulnerability_scan(target, self.config)
    
    async def scan_multiple_targets(self, targets: List[str]) -> Dict[str, Any]:
        """Scan multiple targets for vulnerabilities."""
        self.logger.info(f"Starting vulnerability scan of {len(targets)} targets")
        
        tasks = [self.scan_target(target) for target in targets]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Filter out exceptions
        valid_results = [r for r in results if isinstance(r, dict)]
        
        return {
            "targets_scanned": len(targets),
            "successful_scans": len(valid_results),
            "results": valid_results,
            "overall_summary": self._generate_overall_summary(valid_results)
        }
    
    def _generate_overall_summary(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate overall summary from multiple scan results."""
        total_vulns = 0
        overall_severity_counts = {"low": 0, "medium": 0, "high": 0, "critical": 0}
        
        for result in results:
            if "summary" in result:
                total_vulns += result["summary"]["total_vulnerabilities"]
                for severity, count in result["summary"]["severity_distribution"].items():
                    overall_severity_counts[severity] += count
        
        return {
            "total_vulnerabilities": total_vulns,
            "severity_distribution": overall_severity_counts,
            "average_risk_score": sum(r.get("summary", {}).get("risk_score", 0) for r in results) / len(results) if results else 0
        }

# Named exports
__all__ = [
    'scan_ssl_vulnerabilities',
    'scan_web_vulnerabilities',
    'scan_network_vulnerabilities',
    'comprehensive_vulnerability_scan',
    'calculate_risk_score',
    'VulnerabilityConfig',
    'VulnerabilityResult',
    'VulnerabilityScanner'
] 