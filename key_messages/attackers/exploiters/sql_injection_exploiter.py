from typing_extensions import Literal, TypedDict
from typing import Any, List, Dict, Optional, Union, Tuple
from typing import Dict, List, Optional
from pydantic import BaseModel, field_validator
import asyncio
import aiohttp
import structlog
import re
from typing import Any, List, Dict, Optional
import logging
"""
SQL Injection exploitation module.
"""

logger = structlog.get_logger(__name__)

class SQLInjectionInput(BaseModel):
    """Input model for SQL injection exploitation."""
    target_url: str
    injection_points: List[str]  # Parameter names to test
    payloads: List[str]  # SQL injection payloads to try
    method: str = "GET"  # HTTP method
    timeout_seconds: int = 30
    max_concurrent: int = 10
    
    @field_validator('target_url')
    def validate_url(cls, v) -> bool:
        if not v or not v.startswith(('http://', 'https://')):
            raise ValueError("Target URL must be a valid HTTP/HTTPS URL")
        return v
    
    @field_validator('injection_points')
    def validate_injection_points(cls, v) -> bool:
        if not v or len(v) == 0:
            raise ValueError("Injection points cannot be empty")
        return v
    
    @field_validator('payloads')
    def validate_payloads(cls, v) -> bool:
        if not v or len(v) == 0:
            raise ValueError("Payloads cannot be empty")
        return v
    
    @field_validator('method')
    def validate_method(cls, v) -> bool:
        if v.upper() not in ['GET', 'POST', 'PUT', 'DELETE']:
            raise ValueError("Method must be GET, POST, PUT, or DELETE")
        return v.upper()

class SQLInjectionResult(BaseModel):
    """Result model for SQL injection exploitation."""
    target_url: str
    vulnerable_points: List[Dict[str, str]]
    successful_payloads: List[Dict[str, str]]
    total_tests: int
    duration_seconds: float
    is_completed: bool
    error_message: Optional[str] = None

async def sql_injection_exploiter(input_data: SQLInjectionInput) -> SQLInjectionResult:
    """
    RORO: Receive SQLInjectionInput, return SQLInjectionResult
    
    Perform SQL injection exploitation against target URL.
    """
    start_time = asyncio.get_event_loop().time()
    vulnerable_points = []
    successful_payloads = []
    total_tests = 0
    
    try:
        semaphore = asyncio.Semaphore(input_data.max_concurrent)
        
        async def test_injection_point(point: str, payload: str) -> Optional[Dict[str, str]]:
            """Test a single injection point with a payload."""
            async with semaphore:
                try:
                    async with aiohttp.ClientSession() as session:
                        # Prepare request data
                        if input_data.method == "GET":
                            params = {point: payload}
                            async with session.get(
                                input_data.target_url,
                                params=params,
                                timeout=aiohttp.ClientTimeout(total=input_data.timeout_seconds)
                            ) as response:
                                content = await response.text()
                                return await analyze_response(point, payload, content, response.status)
                        else:
                            data = {point: payload}
                            async with session.post(
                                input_data.target_url,
                                data=data,
                                timeout=aiohttp.ClientTimeout(total=input_data.timeout_seconds)
                            ) as response:
                                content = await response.text()
                                return await analyze_response(point, payload, content, response.status)
                                
                except Exception as e:
                    logger.error("SQL injection test error", 
                               url=input_data.target_url,
                               point=point,
                               payload=payload,
                               error=str(e))
                    return None
        
        async def analyze_response(point: str, payload: str, content: str, status: int) -> Optional[Dict[str, str]]:
            """Analyze response for SQL injection indicators."""
            # Common SQL error patterns
            sql_error_patterns = [
                r"SQL syntax.*MySQL",
                r"Warning.*mysql_.*",
                r"valid MySQL result",
                r"MySqlClient\.",
                r"ORA-[0-9]{5}",
                r"Oracle error",
                r"PostgreSQL.*ERROR",
                r"Warning.*\Wpg_.*",
                r"valid PostgreSQL result",
                r"SQLite/JDBCDriver",
                r"SQLite.Exception",
                r"System.Data.SQLite.SQLiteException",
                r"Warning.*sqlite_.*",
                r"Microsoft SQL Native Client error",
                r"ODBC SQL Server Driver",
                r"Unclosed quotation mark after the character string",
                r"quoted string not properly terminated"
            ]
            
            for pattern in sql_error_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    logger.info("SQL injection vulnerability found", 
                              url=input_data.target_url,
                              point=point,
                              payload=payload,
                              pattern=pattern)
                    return {
                        "injection_point": point,
                        "payload": payload,
                        "error_pattern": pattern,
                        "status_code": status
                    }
            
            return None
        
        # Create tasks for all injection point/payload combinations
        tasks = []
        for point in input_data.injection_points:
            for payload in input_data.payloads:
                task = test_injection_point(point, payload)
                tasks.append(task)
                total_tests += 1
        
        # Execute all tasks concurrently
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process results
        for result in results:
            if isinstance(result, dict) and result is not None:
                vulnerable_points.append(result)
                successful_payloads.append(result)
        
        duration = asyncio.get_event_loop().time() - start_time
        
        logger.info("SQL injection exploitation completed", 
                   url=input_data.target_url,
                   vulnerable_points=len(vulnerable_points),
                   total_tests=total_tests,
                   duration=duration)
        
        return SQLInjectionResult(
            target_url=input_data.target_url,
            vulnerable_points=vulnerable_points,
            successful_payloads=successful_payloads,
            total_tests=total_tests,
            duration_seconds=duration,
            is_completed=True
        )
        
    except Exception as e:
        duration = asyncio.get_event_loop().time() - start_time
        logger.error("SQL injection exploitation failed", 
                    url=input_data.target_url, 
                    error=str(e))
        
        return SQLInjectionResult(
            target_url=input_data.target_url,
            vulnerable_points=vulnerable_points,
            successful_payloads=successful_payloads,
            total_tests=total_tests,
            duration_seconds=duration,
            is_completed=False,
            error_message=str(e)
        ) 