"""
Vulnerability Scanner for HeyGen AI
===================================

Provides web vulnerability scanning capabilities for security testing
and penetration testing.
"""

import asyncio
import re
import time
import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set, Tuple, Any
from urllib.parse import urljoin, urlparse
import aiohttp
import json

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class VulnerabilityFinding:
    """Represents a vulnerability finding."""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    url: str
    parameter: Optional[str] = None
    payload: Optional[str] = None
    response: Optional[str] = None
    confidence: float = 0.0
    references: List[str] = field(default_factory=list)
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None


@dataclass
class ScanConfig:
    """Configuration for vulnerability scanning."""
    timeout: float = 10.0
    max_concurrent: int = 10
    follow_redirects: bool = True
    max_redirects: int = 5
    user_agent: str = "HeyGen-AI-Vulnerability-Scanner/1.0"
    delay_between_requests: float = 0.1
    scan_depth: int = 2
    include_parameters: bool = True


class WebVulnerabilityScanner:
    """Web vulnerability scanner."""
    
    def __init__(self, config: Optional[ScanConfig] = None):
        """Initialize the vulnerability scanner."""
        self.config = config or ScanConfig()
        self.logger = logging.getLogger(__name__)
        self.session: Optional[aiohttp.ClientSession] = None
        self._vulnerability_patterns = self._load_vulnerability_patterns()
        self._scan_results: List[VulnerabilityFinding] = []
    
    def _load_vulnerability_patterns(self) -> Dict[str, Dict]:
        """Load vulnerability detection patterns."""
        return {
            "sql_injection": {
                "patterns": [
                    r"SQL syntax.*error",
                    r"Warning.*mysql_.*",
                    r"valid MySQL result",
                    r"PostgreSQL.*ERROR",
                    r"Warning.*pg_.*",
                    r"valid PostgreSQL result",
                    r"ORA-\d{5}",
                    r"Microsoft.*ODBC.*SQL Server",
                    r"SQLServer JDBC Driver",
                    r"SQLException"
                ],
                "payloads": [
                    "' OR '1'='1",
                    "' OR 1=1--",
                    "'; DROP TABLE users; --",
                    "' UNION SELECT NULL--",
                    "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--"
                ],
                "severity": VulnerabilitySeverity.HIGH
            },
            "xss": {
                "patterns": [
                    r"<script[^>]*>.*</script>",
                    r"javascript:",
                    r"on\w+\s*=",
                    r"<iframe[^>]*>",
                    r"<object[^>]*>",
                    r"<embed[^>]*>"
                ],
                "payloads": [
                    "<script>alert('XSS')</script>",
                    "javascript:alert('XSS')",
                    "<img src=x onerror=alert('XSS')>",
                    "<svg onload=alert('XSS')>",
                    "<iframe src=javascript:alert('XSS')>"
                ],
                "severity": VulnerabilitySeverity.MEDIUM
            },
            "path_traversal": {
                "patterns": [
                    r"root:x:0:0:",
                    r"\[boot loader\]",
                    r"\[fonts\]",
                    r"\[extensions\]",
                    r"\[mci\]",
                    r"\[drivers\]",
                    r"\[386enh\]"
                ],
                "payloads": [
                    "../../../etc/passwd",
                    "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                    "....//....//....//etc/passwd",
                    "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
                ],
                "severity": VulnerabilitySeverity.HIGH
            },
            "command_injection": {
                "patterns": [
                    r"uid=\d+.*gid=\d+",
                    r"total \d+",
                    r"Volume in drive",
                    r"Directory of",
                    r"Microsoft Windows"
                ],
                "payloads": [
                    "; ls -la",
                    "| whoami",
                    "& dir",
                    "; cat /etc/passwd",
                    "| type C:\\windows\\system32\\drivers\\etc\\hosts"
                ],
                "severity": VulnerabilitySeverity.HIGH
            },
            "xxe": {
                "patterns": [
                    r"<!DOCTYPE.*SYSTEM",
                    r"<!ENTITY.*SYSTEM",
                    r"file:///",
                    r"http://",
                    r"ftp://"
                ],
                "payloads": [
                    "<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]><root>&test;</root>",
                    "<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY test SYSTEM 'http://evil.com/xxe'>]><root>&test;</root>"
                ],
                "severity": VulnerabilitySeverity.HIGH
            }
        }
    
    async def __aenter__(self):
        """Async context manager entry."""
        await self.start()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.stop()
    
    async def start(self):
        """Start the scanner session."""
        timeout = aiohttp.ClientTimeout(total=self.config.timeout)
        connector = aiohttp.TCPConnector(limit=self.config.max_concurrent)
        
        self.session = aiohttp.ClientSession(
            timeout=timeout,
            connector=connector,
            headers={"User-Agent": self.config.user_agent}
        )
        self.logger.info("Vulnerability scanner started")
    
    async def stop(self):
        """Stop the scanner session."""
        if self.session:
            await self.session.close()
            self.session = None
        self.logger.info("Vulnerability scanner stopped")
    
    async def scan_url(self, url: str) -> List[VulnerabilityFinding]:
        """Scan a single URL for vulnerabilities."""
        if not self.session:
            await self.start()
        
        findings = []
        
        try:
            # Get the base page first
            async with self.session.get(url) as response:
                if response.status == 200:
                    content = await response.text()
                    
                    # Scan for reflected vulnerabilities
                    findings.extend(await self._scan_reflected_vulnerabilities(url, content))
                    
                    # Extract forms and parameters
                    forms = self._extract_forms(content, url)
                    for form in forms:
                        findings.extend(await self._scan_form_vulnerabilities(form))
                    
                    # Extract links for deeper scanning
                    if self.config.scan_depth > 0:
                        links = self._extract_links(content, url)
                        for link in links[:10]:  # Limit to first 10 links
                            link_findings = await self.scan_url(link)
                            findings.extend(link_findings)
                
        except Exception as e:
            self.logger.error(f"Error scanning URL {url}: {e}")
        
        return findings
    
    async def _scan_reflected_vulnerabilities(self, url: str, content: str) -> List[VulnerabilityFinding]:
        """Scan for reflected vulnerabilities in page content."""
        findings = []
        
        for vuln_type, vuln_config in self._vulnerability_patterns.items():
            for pattern in vuln_config["patterns"]:
                if re.search(pattern, content, re.IGNORECASE):
                    finding = VulnerabilityFinding(
                        id=f"{vuln_type}_{int(time.time())}",
                        title=f"Potential {vuln_type.replace('_', ' ').title()}",
                        description=f"Detected potential {vuln_type} vulnerability in response",
                        severity=vuln_config["severity"],
                        url=url,
                        confidence=0.7,
                        cwe_id=self._get_cwe_id(vuln_type)
                    )
                    findings.append(finding)
        
        return findings
    
    async def _scan_form_vulnerabilities(self, form: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Scan form for vulnerabilities."""
        findings = []
        
        if not self.session:
            return findings
        
        for vuln_type, vuln_config in self._vulnerability_patterns.items():
            for payload in vuln_config["payloads"]:
                try:
                    # Prepare form data with payload
                    form_data = form["data"].copy()
                    for field in form["fields"]:
                        if field["type"] in ["text", "password", "textarea"]:
                            form_data[field["name"]] = payload
                    
                    # Submit form
                    async with self.session.request(
                        form["method"], 
                        form["action"], 
                        data=form_data
                    ) as response:
                        content = await response.text()
                        
                        # Check for vulnerability indicators
                        for pattern in vuln_config["patterns"]:
                            if re.search(pattern, content, re.IGNORECASE):
                                finding = VulnerabilityFinding(
                                    id=f"{vuln_type}_{int(time.time())}",
                                    title=f"{vuln_type.replace('_', ' ').title()} Vulnerability",
                                    description=f"Confirmed {vuln_type} vulnerability in form",
                                    severity=vuln_config["severity"],
                                    url=form["action"],
                                    parameter=field["name"],
                                    payload=payload,
                                    response=content[:500],  # First 500 chars
                                    confidence=0.9,
                                    cwe_id=self._get_cwe_id(vuln_type)
                                )
                                findings.append(finding)
                                break
                    
                    # Add delay between requests
                    if self.config.delay_between_requests > 0:
                        await asyncio.sleep(self.config.delay_between_requests)
                
                except Exception as e:
                    self.logger.error(f"Error testing form vulnerability: {e}")
        
        return findings
    
    def _extract_forms(self, content: str, base_url: str) -> List[Dict[str, Any]]:
        """Extract forms from HTML content."""
        forms = []
        
        # Simple form extraction using regex
        form_pattern = r'<form[^>]*action=["\']([^"\']*)["\'][^>]*>(.*?)</form>'
        form_matches = re.findall(form_pattern, content, re.DOTALL | re.IGNORECASE)
        
        for action, form_content in form_matches:
            form = {
                "action": urljoin(base_url, action),
                "method": "GET",
                "fields": [],
                "data": {}
            }
            
            # Extract method
            method_match = re.search(r'method=["\']([^"\']*)["\']', form_content, re.IGNORECASE)
            if method_match:
                form["method"] = method_match.group(1).upper()
            
            # Extract input fields
            input_pattern = r'<input[^>]*name=["\']([^"\']*)["\'][^>]*>'
            input_matches = re.findall(input_pattern, form_content, re.IGNORECASE)
            
            for name in input_matches:
                field = {
                    "name": name,
                    "type": "text"
                }
                
                # Extract type
                type_match = re.search(rf'<input[^>]*name=["\']?{re.escape(name)}["\']?[^>]*type=["\']([^"\']*)["\']', 
                                     form_content, re.IGNORECASE)
                if type_match:
                    field["type"] = type_match.group(1)
                
                form["fields"].append(field)
                form["data"][name] = ""
            
            if form["fields"]:
                forms.append(form)
        
        return forms
    
    def _extract_links(self, content: str, base_url: str) -> List[str]:
        """Extract links from HTML content."""
        links = set()
        
        # Extract href links
        href_pattern = r'href=["\']([^"\']*)["\']'
        href_matches = re.findall(href_pattern, content, re.IGNORECASE)
        
        for href in href_matches:
            full_url = urljoin(base_url, href)
            parsed = urlparse(full_url)
            if parsed.netloc == urlparse(base_url).netloc:  # Same domain
                links.add(full_url)
        
        return list(links)
    
    def _get_cwe_id(self, vuln_type: str) -> str:
        """Get CWE ID for vulnerability type."""
        cwe_mapping = {
            "sql_injection": "CWE-89",
            "xss": "CWE-79",
            "path_traversal": "CWE-22",
            "command_injection": "CWE-78",
            "xxe": "CWE-611"
        }
        return cwe_mapping.get(vuln_type, "CWE-000")
    
    async def scan_multiple_urls(self, urls: List[str]) -> List[VulnerabilityFinding]:
        """Scan multiple URLs for vulnerabilities."""
        all_findings = []
        
        semaphore = asyncio.Semaphore(self.config.max_concurrent)
        
        async def scan_with_semaphore(url: str) -> List[VulnerabilityFinding]:
            async with semaphore:
                return await self.scan_url(url)
        
        tasks = [scan_with_semaphore(url) for url in urls]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, list):
                all_findings.extend(result)
            elif isinstance(result, Exception):
                self.logger.error(f"Error in parallel scan: {result}")
        
        return all_findings
    
    def filter_findings(self, findings: List[VulnerabilityFinding], 
                       severity: Optional[VulnerabilitySeverity] = None,
                       vuln_type: Optional[str] = None) -> List[VulnerabilityFinding]:
        """Filter findings by severity or type."""
        filtered = findings
        
        if severity:
            filtered = [f for f in filtered if f.severity == severity]
        
        if vuln_type:
            filtered = [f for f in filtered if vuln_type in f.title.lower()]
        
        return filtered
    
    def group_findings_by_severity(self, findings: List[VulnerabilityFinding]) -> Dict[VulnerabilitySeverity, List[VulnerabilityFinding]]:
        """Group findings by severity level."""
        grouped = {severity: [] for severity in VulnerabilitySeverity}
        
        for finding in findings:
            grouped[finding.severity].append(finding)
        
        return grouped
    
    def generate_report(self, findings: List[VulnerabilityFinding]) -> str:
        """Generate a text report from scan findings."""
        if not findings:
            return "No vulnerabilities found."
        
        report_lines = []
        report_lines.append("VULNERABILITY SCAN REPORT")
        report_lines.append("=" * 50)
        report_lines.append(f"Total Findings: {len(findings)}")
        report_lines.append("")
        
        # Group by severity
        grouped = self.group_findings_by_severity(findings)
        
        for severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH, 
                        VulnerabilitySeverity.MEDIUM, VulnerabilitySeverity.LOW, VulnerabilitySeverity.INFO]:
            if grouped[severity]:
                report_lines.append(f"{severity.value.upper()} SEVERITY ({len(grouped[severity])} findings)")
                report_lines.append("-" * 30)
                
                for finding in grouped[severity]:
                    report_lines.append(f"Title: {finding.title}")
                    report_lines.append(f"URL: {finding.url}")
                    if finding.parameter:
                        report_lines.append(f"Parameter: {finding.parameter}")
                    if finding.cwe_id:
                        report_lines.append(f"CWE: {finding.cwe_id}")
                    report_lines.append(f"Confidence: {finding.confidence:.2f}")
                    report_lines.append("")
        
        return "\n".join(report_lines)
    
    def export_findings(self, findings: List[VulnerabilityFinding], format: str = "json") -> str:
        """Export findings in specified format."""
        if format.lower() == "json":
            findings_data = []
            for finding in findings:
                findings_data.append({
                    "id": finding.id,
                    "title": finding.title,
                    "description": finding.description,
                    "severity": finding.severity.value,
                    "url": finding.url,
                    "parameter": finding.parameter,
                    "payload": finding.payload,
                    "confidence": finding.confidence,
                    "cwe_id": finding.cwe_id,
                    "cvss_score": finding.cvss_score
                })
            return json.dumps(findings_data, indent=2)
        
        elif format.lower() == "csv":
            csv_lines = ["ID,Title,Severity,URL,Parameter,Confidence,CWE"]
            for finding in findings:
                csv_lines.append(f"{finding.id},{finding.title},{finding.severity.value},"
                               f"{finding.url},{finding.parameter or ''},{finding.confidence},"
                               f"{finding.cwe_id or ''}")
            return "\n".join(csv_lines)
        
        else:
            return self.generate_report(findings)



