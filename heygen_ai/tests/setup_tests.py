from typing_extensions import Literal, TypedDict
from typing import Any, List, Dict, Optional, Union, Tuple
from dataclasses import dataclass

# Constants
TIMEOUT_SECONDS = 60

import argparse
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Dict, Any
        import redis
        import psycopg2
        from domain.exceptions.domain_errors import DomainError
        from domain.value_objects.email import Email
        import pytest
        import pytest_asyncio
        import httpx
from typing import Any, List, Dict, Optional
import logging
import asyncio
#!/usr/bin/env python3
"""
HeyGen AI Testing Framework Setup Script
========================================

Sets up the testing environment for the HeyGen AI service.
This script prepares the testing environment, installs dependencies,
and validates the test configuration.

Usage:
    python tests/setup_tests.py            # Basic setup
    python tests/setup_tests.py --full     # Full setup with databases
    python tests/setup_tests.py --check    # Check current setup
"""


# Colors for terminal output
@dataclass
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    BOLD = '\033[1m'
    END = '\033[0m'

def print_step(message: str, status: str = "info"):
    """Print a colored step message."""
    color = {
        "info": Colors.BLUE,
        "success": Colors.GREEN,
        "warning": Colors.YELLOW,
        "error": Colors.RED
    }.get(status, Colors.BLUE)
    
    print(f"{color}{Colors.BOLD}→{Colors.END} {color}{message}{Colors.END}")

def run_command(cmd: List[str], description: str) -> bool:
    """Run a command and return success status."""
    try:
        print_step(f"Running: {description}")
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return True
    except subprocess.CalledProcessError as e:
        print_step(f"Failed: {description}", "error")
        print(f"  Error: {e.stderr}")
        return False

def check_python_version() -> bool:
    """Check if Python version meets requirements."""
    print_step("Checking Python version")
    
    if sys.version_info < (3, 9):
        print_step("Python 3.9+ is required", "error")
        return False
    
    print_step(f"Python {sys.version_info.major}.{sys.version_info.minor} ✓", "success")
    return True

def install_dependencies() -> bool:
    """Install test dependencies."""
    print_step("Installing test dependencies")
    
    requirements_file = Path(__file__).parent.parent / "requirements-test.txt"
    
    if not requirements_file.exists():
        print_step("requirements-test.txt not found", "error")
        return False
    
    return run_command(
        [sys.executable, "-m", "pip", "install", "-r", str(requirements_file)],
        "Installing test requirements"
    )

def setup_test_environment() -> bool:
    """Set up test environment variables."""
    print_step("Setting up test environment")
    
    env_vars = {
        "ENVIRONMENT": "testing",
        "DEBUG": "true",
        "DATABASE_URL": "sqlite:///test.db",
        "REDIS_URL": "redis://localhost:6379/1",
        "HEYGEN_API_URL": "https://api.test.heygen.ai",
        "HEYGEN_API_KEY": "test_api_key",
        "LOG_LEVEL": "DEBUG",
    }
    
    # Create .env.test file
    env_file = Path(__file__).parent.parent / ".env.test"
    
    with open(env_file, "w") as f:
    try:
        pass
    except Exception as e:
        print(f"Error: {e}")
        f.write("# Test Environment Configuration\n")
    try:
        pass
    except Exception as e:
        print(f"Error: {e}")
        f.write("# Generated by setup_tests.py\n\n")
    try:
        pass
    except Exception as e:
        print(f"Error: {e}")
        
        for key, value in env_vars.items():
            f.write(f"{key}={value}\n")
    try:
        pass
    except Exception as e:
        print(f"Error: {e}")
    
    print_step(f"Created {env_file}", "success")
    return True

def setup_test_database() -> bool:
    """Set up test database."""
    print_step("Setting up test database")
    
    # Remove existing test database
    test_db = Path("test.db")
    if test_db.exists():
        test_db.unlink()
        print_step("Removed existing test database", "info")
    
    # Create test directories
    test_dirs = [
        Path(__file__).parent / "reports",
        Path(__file__).parent / "fixtures" / "data",
        Path(__file__).parent / "utils" / "temp",
    ]
    
    for directory in test_dirs:
        directory.mkdir(parents=True, exist_ok=True)
        print_step(f"Created directory: {directory}", "success")
    
    return True

def check_external_services() -> Dict[str, bool]:
    """Check availability of external services."""
    print_step("Checking external services")
    
    services = {}
    
    # Check Redis
    try:
        r = redis.Redis(host='localhost', port=6379, db=1, decode_responses=True)
        r.ping()
        services['redis'] = True
        print_step("Redis connection ✓", "success")
    except Exception:
        services['redis'] = False
        print_step("Redis not available (tests will use mocks)", "warning")
    
    # Check PostgreSQL (optional)
    try:
        # This is just a connection test, actual connection details would come from env
        services['postgresql'] = True
        print_step("PostgreSQL driver available ✓", "success")
    except ImportError:
        services['postgresql'] = False
        print_step("PostgreSQL driver not available (using SQLite)", "warning")
    
    return services

def validate_test_structure() -> bool:
    """Validate test directory structure."""
    print_step("Validating test structure")
    
    required_dirs = [
        "unit/domain",
        "unit/application", 
        "unit/infrastructure",
        "unit/presentation",
        "integration",
        "performance",
        "fixtures",
        "utils"
    ]
    
    base_dir = Path(__file__).parent
    missing_dirs = []
    
    for dir_path in required_dirs:
        full_path = base_dir / dir_path
        if not full_path.exists():
            full_path.mkdir(parents=True, exist_ok=True)
            print_step(f"Created missing directory: {dir_path}", "info")
        else:
            print_step(f"Directory exists: {dir_path} ✓", "success")
    
    return True

def run_test_validation() -> bool:
    """Run a quick test to validate setup."""
    print_step("Running test validation")
    
    # Import test to check if everything is working
    try:
        # Try to import our modules
        sys.path.insert(0, str(Path(__file__).parent.parent))
        
        print_step("Testing imports", "info")
        
        # Test basic functionality
        email = Email("test@example.com")
        assert email.value == "test@example.com"
        
        print_step("Basic functionality test ✓", "success")
        return True
        
    except Exception as e:
        print_step(f"Validation failed: {e}", "error")
        return False

def run_sample_tests() -> bool:
    """Run a small sample of tests to verify everything works."""
    print_step("Running sample tests")
    
    project_root = Path(__file__).parent.parent
    
    # Run a simple pytest command
    cmd = [
        sys.executable, "-m", "pytest", 
        str(Path(__file__).parent / "unit" / "domain" / "test_value_objects.py"),
        "-v", "--tb=short", "-x"  # Stop on first failure
    ]
    
    try:
        result = subprocess.run(
            cmd, 
            cwd=project_root,
            capture_output=True, 
            text=True, 
            timeout=60
        )
        
        if result.returncode == 0:
            print_step("Sample tests passed ✓", "success")
            return True
        else:
            print_step("Sample tests failed", "error")
            print(f"stdout: {result.stdout}")
            print(f"stderr: {result.stderr}")
            return False
            
    except subprocess.TimeoutExpired:
        print_step("Sample tests timed out", "error")
        return False
    except Exception as e:
        print_step(f"Error running sample tests: {e}", "error")
        return False

def check_current_setup() -> Dict[str, Any]:
    """Check current testing setup status."""
    print_step("Checking current setup status", "info")
    
    status = {
        "python_version": check_python_version(),
        "test_structure": validate_test_structure(),
        "external_services": check_external_services(),
    }
    
    # Check if dependencies are installed
    try:
        status["dependencies"] = True
        print_step("Test dependencies installed ✓", "success")
    except ImportError:
        status["dependencies"] = False
        print_step("Test dependencies missing", "error")
    
    # Check environment file
    env_file = Path(__file__).parent.parent / ".env.test"
    status["env_file"] = env_file.exists()
    
    if status["env_file"]:
        print_step("Test environment file exists ✓", "success")
    else:
        print_step("Test environment file missing", "warning")
    
    return status

def main():
    """Main setup function."""
    parser = argparse.ArgumentParser(
        description="HeyGen AI Testing Framework Setup",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument('--full', action='store_true', 
                       help='Full setup including external services')
    parser.add_argument('--check', action='store_true',
                       help='Check current setup status')
    parser.add_argument('--validate', action='store_true',
                       help='Run validation tests')
    
    args = parser.parse_args()
    
    print(f"{Colors.BOLD}{Colors.BLUE}🧪 HeyGen AI Testing Framework Setup{Colors.END}")
    print("=" * 50)
    
    if args.check:
        status = check_current_setup()
        
        print("\n📊 Setup Status Summary:")
        for component, is_ok in status.items():
            if isinstance(is_ok, bool):
                icon = "✅" if is_ok else "❌"
                print(f"  {icon} {component.replace('_', ' ').title()}")
            elif isinstance(is_ok, dict):
                print(f"  📋 {component.replace('_', ' ').title()}:")
                for service, available in is_ok.items():
                    icon = "✅" if available else "⚠️"
                    print(f"    {icon} {service}")
        
        return
    
    # Step-by-step setup
    steps = [
        ("Check Python version", check_python_version),
        ("Install dependencies", install_dependencies),
        ("Setup test environment", setup_test_environment),
        ("Setup test database", setup_test_database),
        ("Validate test structure", validate_test_structure),
    ]
    
    if args.full:
        steps.append(("Check external services", lambda: check_external_services() is not None))
    
    if args.validate:
        steps.extend([
            ("Run test validation", run_test_validation),
            ("Run sample tests", run_sample_tests),
        ])
    
    # Execute steps
    failed_steps = []
    for step_name, step_func in steps:
        try:
            if not step_func():
                failed_steps.append(step_name)
        except Exception as e:
            print_step(f"Error in {step_name}: {e}", "error")
            failed_steps.append(step_name)
    
    # Summary
    print("\n" + "=" * 50)
    if failed_steps:
        print_step("⚠️  Setup completed with issues", "warning")
        print("Failed steps:")
        for step in failed_steps:
            print(f"  ❌ {step}")
        sys.exit(1)
    else:
        print_step("✅ Setup completed successfully!", "success")
        print("\nNext steps:")
        print("  1. Run tests: python tests/test_runner.py --unit")
        print("  2. Check coverage: python tests/test_runner.py --unit --coverage")
        print("  3. Run all tests: python tests/test_runner.py --all")
        sys.exit(0)

match __name__:
    case "__main__":
    main() 